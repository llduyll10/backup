{"version":3,"sources":["vendor/ember-cli/test-support-suffix.js","bower_components/ember-qunit/dist/named-amd/main.js","bower_components/ember-cli-shims/test-shims.js","bower_components/qunit/qunit/qunit.js","bower_components/qunit-notifications/index.js","vendor/qunit-bdd/lib/qunit-bdd.js","bower_components/sinon/index.js"],"sourcesContent":["/* jshint ignore:start */\n\nrunningTests = true;\n\n/* jshint ignore:end */\n","define(\"ember-qunit/isolated-container\",\n  [\"./test-resolver\",\"ember\",\"exports\"],\n  function(__dependency1__, __dependency2__, __exports__) {\n    \"use strict\";\n    var testResolver = __dependency1__[\"default\"] || __dependency1__;\n    var Ember = __dependency2__[\"default\"] || __dependency2__;\n\n    __exports__[\"default\"] = function isolatedContainer(fullNames) {\n      var resolver = testResolver.get();\n      var container = new Ember.Container();\n      container.optionsForType('component', { singleton: false });\n      container.optionsForType('view', { singleton: false });\n      container.optionsForType('template', { instantiate: false });\n      container.optionsForType('helper', { instantiate: false });\n      container.register('component-lookup:main', Ember.ComponentLookup);\n      for (var i = fullNames.length; i > 0; i--) {\n        var fullName = fullNames[i - 1];\n        container.register(fullName, resolver.resolve(fullName));\n      }\n      return container;\n    }\n  });define(\"ember-qunit\",\n  [\"ember\",\"./isolated-container\",\"./module-for\",\"./module-for-component\",\"./module-for-model\",\"./test\",\"./test-resolver\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {\n    \"use strict\";\n    var Ember = __dependency1__[\"default\"] || __dependency1__;\n    var isolatedContainer = __dependency2__[\"default\"] || __dependency2__;\n    var moduleFor = __dependency3__[\"default\"] || __dependency3__;\n    var moduleForComponent = __dependency4__[\"default\"] || __dependency4__;\n    var moduleForModel = __dependency5__[\"default\"] || __dependency5__;\n    var test = __dependency6__[\"default\"] || __dependency6__;\n    var testResolver = __dependency7__[\"default\"] || __dependency7__;\n\n    Ember.testing = true;\n\n    function setResolver(resolver) {\n      testResolver.set(resolver);\n    }\n\n    function globalize() {\n      window.moduleFor = moduleFor;\n      window.moduleForComponent = moduleForComponent;\n      window.moduleForModel = moduleForModel;\n      window.test = test;\n      window.setResolver = setResolver;\n    }\n\n    __exports__.globalize = globalize;\n    __exports__.moduleFor = moduleFor;\n    __exports__.moduleForComponent = moduleForComponent;\n    __exports__.moduleForModel = moduleForModel;\n    __exports__.test = test;\n    __exports__.setResolver = setResolver;\n  });define(\"ember-qunit/module-for-component\",\n  [\"./test-resolver\",\"./module-for\",\"ember\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {\n    \"use strict\";\n    var testResolver = __dependency1__[\"default\"] || __dependency1__;\n    var moduleFor = __dependency2__[\"default\"] || __dependency2__;\n    var Ember = __dependency3__[\"default\"] || __dependency3__;\n\n    __exports__[\"default\"] = function moduleForComponent(name, description, callbacks) {\n      var resolver = testResolver.get();\n\n      moduleFor('component:' + name, description, callbacks, function(container, context, defaultSubject) {\n        var layoutName = 'template:components/' + name;\n\n        var layout = resolver.resolve(layoutName);\n\n        if (layout) {\n          container.register(layoutName, layout);\n          container.injection('component:' + name, 'layout', layoutName);\n        }\n\n        context.dispatcher = Ember.EventDispatcher.create();\n        context.dispatcher.setup({}, '#ember-testing');\n\n        context.__setup_properties__.append = function(selector) {\n          var containerView = Ember.ContainerView.create({container: container});\n          var view = Ember.run(function(){\n            var subject = context.subject();\n            containerView.pushObject(subject);\n            // TODO: destory this somewhere\n            containerView.appendTo('#ember-testing');\n            return subject;\n          });\n\n          return view.$();\n        };\n        context.__setup_properties__.$ = context.__setup_properties__.append;\n      });\n    }\n  });define(\"ember-qunit/module-for-model\",\n  [\"./module-for\",\"ember\",\"exports\"],\n  function(__dependency1__, __dependency2__, __exports__) {\n    \"use strict\";\n    var moduleFor = __dependency1__[\"default\"] || __dependency1__;\n    var Ember = __dependency2__[\"default\"] || __dependency2__;\n\n    __exports__[\"default\"] = function moduleForModel(name, description, callbacks) {\n      moduleFor('model:' + name, description, callbacks, function(container, context, defaultSubject) {\n        if (DS._setupContainer) {\n          DS._setupContainer(container);\n        } else {\n          container.register('store:main', DS.Store);\n        }\n\n        var adapterFactory = container.lookupFactory('adapter:application');\n        if (!adapterFactory) {\n          container.register('adapter:application', DS.FixtureAdapter);\n        }\n\n        context.__setup_properties__.store = function(){\n          return container.lookup('store:main');\n        };\n\n        if (context.__setup_properties__.subject === defaultSubject) {\n          context.__setup_properties__.subject = function(options) {\n            return Ember.run(function() {\n              return container.lookup('store:main').createRecord(name, options);\n            });\n          };\n        }\n      });\n    }\n  });define(\"ember-qunit/module-for\",\n  [\"ember\",\"./test-context\",\"./isolated-container\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {\n    \"use strict\";\n    var Ember = __dependency1__[\"default\"] || __dependency1__;\n    //import QUnit from 'qunit'; // Assumed global in runner\n    var testContext = __dependency2__[\"default\"] || __dependency2__;\n    var isolatedContainer = __dependency3__[\"default\"] || __dependency3__;\n\n    __exports__[\"default\"] = function moduleFor(fullName, description, callbacks, delegate) {\n      var container;\n      var context;\n      \n      var _callbacks = {\n        setup: function(){\n          callbacks = callbacks || { };\n\n          var needs = [fullName].concat(callbacks.needs || []);\n          container = isolatedContainer(needs);\n\n          callbacks.subject   = callbacks.subject || defaultSubject;\n\n          callbacks.setup     = callbacks.setup    || function() { };\n          callbacks.teardown  = callbacks.teardown || function() { };\n          \n          function factory() {\n            return container.lookupFactory(fullName);\n          }\n          \n          testContext.set({\n            container:            container,\n            factory:              factory,\n            dispatcher:           null,\n            __setup_properties__: callbacks\n          });\n          \n          context = testContext.get();\n\n          if (delegate) {\n            delegate(container, context, defaultSubject);\n          }\n          \n          if (Ember.$('#ember-testing').length === 0) {\n            Ember.$('<div id=\"ember-testing\"/>').appendTo(document.body);\n          }\n          \n          buildContextVariables(context);\n          callbacks.setup.call(context, container);\n        },\n\n        teardown: function(){\n          Ember.run(function(){\n            container.destroy();\n            \n            if (context.dispatcher) {\n              context.dispatcher.destroy();\n            }\n          });\n          \n          callbacks.teardown(container);\n          Ember.$('#ember-testing').empty();\n        }\n      };\n\n      QUnit.module(description || fullName, _callbacks);\n    }\n\n    function defaultSubject(options, factory) {\n      return factory.create(options);\n    }\n\n    // allow arbitrary named factories, like rspec let\n    function buildContextVariables(context) {\n      var cache     = { };\n      var callbacks = context.__setup_properties__;\n      var container = context.container;\n      var factory   = context.factory;\n        \n      Ember.keys(callbacks).filter(function(key){\n        // ignore the default setup/teardown keys\n        return key !== 'setup' && key !== 'teardown';\n      }).forEach(function(key){\n        context[key] = function(options) {\n          if (cache[key]) { return cache[key]; }\n\n          var result = callbacks[key](options, factory(), container);\n          cache[key] = result;\n          return result;\n        };\n      });\n    }\n  });define(\"ember-qunit/test-context\",\n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    var __test_context__;\n\n    function set(context) {\n      __test_context__ = context;\n    }\n\n    __exports__.set = set;function get() {\n      return __test_context__;\n    }\n\n    __exports__.get = get;\n  });define(\"ember-qunit/test-resolver\",\n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    var __resolver__;\n\n    function set(resolver) {\n      __resolver__ = resolver;\n    }\n\n    __exports__.set = set;function get() {\n      if (__resolver__ == null) throw new Error('you must set a resolver with `testResolver.set(resolver)`');\n      return __resolver__;\n    }\n\n    __exports__.get = get;\n  });define(\"ember-qunit/test\",\n  [\"ember\",\"./test-context\",\"exports\"],\n  function(__dependency1__, __dependency2__, __exports__) {\n    \"use strict\";\n    var Ember = __dependency1__[\"default\"] || __dependency1__;\n    //import QUnit from 'qunit'; // Assumed global in runner\n    var testContext = __dependency2__[\"default\"] || __dependency2__;\n\n    function resetViews() {\n      Ember.View.views = {};\n    }\n\n    __exports__[\"default\"] = function test(testName, callback) {\n\n      function wrapper() {\n        var context = testContext.get();\n        \n        resetViews();\n        var result = callback.call(context);\n\n        function failTestOnPromiseRejection(reason) {\n          ok(false, reason);\n        }\n\n        Ember.run(function(){\n          stop();\n          Ember.RSVP.Promise.cast(result)['catch'](failTestOnPromiseRejection)['finally'](start);\n        });\n      }\n\n      QUnit.test(testName, wrapper);\n    }\n  });","/* global define, QUnit */\ndefine('qunit', [], function() {\n  \"use strict\";\n\n  return {\n    'default': QUnit\n  };\n});","/*!\n * QUnit 1.15.0\n * http://qunitjs.com/\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-08-08T16:00Z\n */\n\n(function( window ) {\n\nvar QUnit,\n\tconfig,\n\tonErrorFnPrev,\n\tfileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" ),\n\ttoString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty,\n\t// Keep a local reference to Date (GH-283)\n\tDate = window.Date,\n\tnow = Date.now || function() {\n\t\treturn new Date().getTime();\n\t},\n\tsetTimeout = window.setTimeout,\n\tclearTimeout = window.clearTimeout,\n\tdefined = {\n\t\tdocument: typeof window.document !== \"undefined\",\n\t\tsetTimeout: typeof window.setTimeout !== \"undefined\",\n\t\tsessionStorage: (function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}())\n\t},\n\t/**\n\t * Provides a normalized error string, correcting an issue\n\t * with IE 7 (and prior) where Error.prototype.toString is\n\t * not properly implemented\n\t *\n\t * Based on http://es5.github.com/#x15.11.4.4\n\t *\n\t * @param {String|Error} error\n\t * @return {String} error message\n\t */\n\terrorString = function( error ) {\n\t\tvar name, message,\n\t\t\terrorString = error.toString();\n\t\tif ( errorString.substring( 0, 7 ) === \"[object\" ) {\n\t\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\t\tif ( name && message ) {\n\t\t\t\treturn name + \": \" + message;\n\t\t\t} else if ( name ) {\n\t\t\t\treturn name;\n\t\t\t} else if ( message ) {\n\t\t\t\treturn message;\n\t\t\t} else {\n\t\t\t\treturn \"Error\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn errorString;\n\t\t}\n\t},\n\t/**\n\t * Makes a clone of an object using only Array or Object as base,\n\t * and copies over the own enumerable properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object} New object with only the own properties (recursively).\n\t */\n\tobjectValues = function( obj ) {\n\t\tvar key, val,\n\t\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\t\tfor ( key in obj ) {\n\t\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\t\tval = obj[ key ];\n\t\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t\t}\n\t\t}\n\t\treturn vals;\n\t};\n\n// Root QUnit object.\n// `QUnit` initialized at top of scope\nQUnit = {\n\n\t// call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment ) {\n\t\tconfig.currentModule = name;\n\t\tconfig.currentModuleTestEnvironment = testEnvironment;\n\t\tconfig.modules[ name ] = true;\n\t},\n\n\tasyncTest: function( testName, expected, callback ) {\n\t\tif ( arguments.length === 2 ) {\n\t\t\tcallback = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tQUnit.test( testName, expected, callback, true );\n\t},\n\n\ttest: function( testName, expected, callback, async ) {\n\t\tvar test;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tcallback = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\ttest = new Test({\n\t\t\ttestName: testName,\n\t\t\texpected: expected,\n\t\t\tasync: async,\n\t\t\tcallback: callback,\n\t\t\tmodule: config.currentModule,\n\t\t\tmoduleTestEnvironment: config.currentModuleTestEnvironment,\n\t\t\tstack: sourceFromStacktrace( 2 )\n\t\t});\n\n\t\tif ( !validTest( test ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\ttest.queue();\n\t},\n\n\tstart: function( count ) {\n\t\tvar message;\n\n\t\t// QUnit hasn't been initialized yet.\n\t\t// Note: RequireJS (et al) may delay onLoad\n\t\tif ( config.semaphore === undefined ) {\n\t\t\tQUnit.begin(function() {\n\t\t\t\t// This is triggered at the top of QUnit.load, push start() to the event loop, to allow QUnit.load to finish first\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tQUnit.start( count );\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconfig.semaphore -= count || 1;\n\t\t// don't start until equal number of stop-calls\n\t\tif ( config.semaphore > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Set the starting time when the first test is run\n\t\tQUnit.config.started = QUnit.config.started || now();\n\t\t// ignore if start is called more often then stop\n\t\tif ( config.semaphore < 0 ) {\n\t\t\tconfig.semaphore = 0;\n\n\t\t\tmessage = \"Called start() while already started (QUnit.config.semaphore was 0 already)\";\n\n\t\t\tif ( config.current ) {\n\t\t\t\tQUnit.pushFailure( message, sourceFromStacktrace( 2 ) );\n\t\t\t} else {\n\t\t\t\tthrow new Error( message );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\t// A slight delay, to avoid any current callbacks\n\t\tif ( defined.setTimeout ) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tif ( config.semaphore > 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( config.timeout ) {\n\t\t\t\t\tclearTimeout( config.timeout );\n\t\t\t\t}\n\n\t\t\t\tconfig.blocking = false;\n\t\t\t\tprocess( true );\n\t\t\t}, 13 );\n\t\t} else {\n\t\t\tconfig.blocking = false;\n\t\t\tprocess( true );\n\t\t}\n\t},\n\n\tstop: function( count ) {\n\t\tconfig.semaphore += count || 1;\n\t\tconfig.blocking = true;\n\n\t\tif ( config.testTimeout && defined.setTimeout ) {\n\t\t\tclearTimeout( config.timeout );\n\t\t\tconfig.timeout = setTimeout(function() {\n\t\t\t\tQUnit.ok( false, \"Test timed out\" );\n\t\t\t\tconfig.semaphore = 1;\n\t\t\t\tQUnit.start();\n\t\t\t}, config.testTimeout );\n\t\t}\n\t}\n};\n\n// We use the prototype to distinguish between properties that should\n// be exposed as globals (and in exports) and those that shouldn't\n(function() {\n\tfunction F() {}\n\tF.prototype = QUnit;\n\tQUnit = new F();\n\n\t// Make F QUnit's constructor so that we can add to the prototype later\n\tQUnit.constructor = F;\n}());\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nconfig = {\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// block until document ready\n\tblocking: true,\n\n\t// when enabled, show only failing tests\n\t// gets persisted through sessionStorage and can be changed in UI via checkbox\n\thidepassed: false,\n\n\t// by default, run previously failed tests first\n\t// very useful in combination with \"Hide passed tests\" checked\n\treorder: true,\n\n\t// by default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// by default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// when enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// add checkboxes that are persisted in the query-string\n\t// when enabled, the id is set to `true` as a `QUnit.config` property\n\turlConfig: [\n\t\t{\n\t\t\tid: \"noglobals\",\n\t\t\tlabel: \"Check for Globals\",\n\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the `window` object. Stored as query-strings.\"\n\t\t},\n\t\t{\n\t\t\tid: \"notrycatch\",\n\t\t\tlabel: \"No try-catch\",\n\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging exceptions in IE reasonable. Stored as query-strings.\"\n\t\t}\n\t],\n\n\t// Set of all modules.\n\tmodules: {},\n\n\tcallbacks: {}\n};\n\n// Initialize more QUnit.config and QUnit.urlParams\n(function() {\n\tvar i, current,\n\t\tlocation = window.location || { search: \"\", protocol: \"file:\" },\n\t\tparams = location.search.slice( 1 ).split( \"&\" ),\n\t\tlength = params.length,\n\t\turlParams = {};\n\n\tif ( params[ 0 ] ) {\n\t\tfor ( i = 0; i < length; i++ ) {\n\t\t\tcurrent = params[ i ].split( \"=\" );\n\t\t\tcurrent[ 0 ] = decodeURIComponent( current[ 0 ] );\n\n\t\t\t// allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tcurrent[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;\n\t\t\tif ( urlParams[ current[ 0 ] ] ) {\n\t\t\t\turlParams[ current[ 0 ] ] = [].concat( urlParams[ current[ 0 ] ], current[ 1 ] );\n\t\t\t} else {\n\t\t\t\turlParams[ current[ 0 ] ] = current[ 1 ];\n\t\t\t}\n\t\t}\n\t}\n\n\tQUnit.urlParams = urlParams;\n\n\t// String search anywhere in moduleName+testName\n\tconfig.filter = urlParams.filter;\n\n\t// Exact match of the module name\n\tconfig.module = urlParams.module;\n\n\tconfig.testNumber = [];\n\tif ( urlParams.testNumber ) {\n\n\t\t// Ensure that urlParams.testNumber is an array\n\t\turlParams.testNumber = [].concat( urlParams.testNumber );\n\t\tfor ( i = 0; i < urlParams.testNumber.length; i++ ) {\n\t\t\tcurrent = urlParams.testNumber[ i ];\n\t\t\tconfig.testNumber.push( parseInt( current, 10 ) );\n\t\t}\n\t}\n\n\t// Figure out if we're running the tests from a server or not\n\tQUnit.isLocal = location.protocol === \"file:\";\n}());\n\nextend( QUnit, {\n\n\tconfig: config,\n\n\t// Safe object type checking\n\tis: function( type, obj ) {\n\t\treturn QUnit.objectType( obj ) === type;\n\t},\n\n\tobjectType: function( obj ) {\n\t\tif ( typeof obj === \"undefined\" ) {\n\t\t\treturn \"undefined\";\n\t\t}\n\n\t\t// Consider: typeof null === object\n\t\tif ( obj === null ) {\n\t\t\treturn \"null\";\n\t\t}\n\n\t\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\t\ttype = match && match[ 1 ] || \"\";\n\n\t\tswitch ( type ) {\n\t\t\tcase \"Number\":\n\t\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\t\treturn \"nan\";\n\t\t\t\t}\n\t\t\t\treturn \"number\";\n\t\t\tcase \"String\":\n\t\t\tcase \"Boolean\":\n\t\t\tcase \"Array\":\n\t\t\tcase \"Date\":\n\t\t\tcase \"RegExp\":\n\t\t\tcase \"Function\":\n\t\t\t\treturn type.toLowerCase();\n\t\t}\n\t\tif ( typeof obj === \"object\" ) {\n\t\t\treturn \"object\";\n\t\t}\n\t\treturn undefined;\n\t},\n\n\turl: function( params ) {\n\t\tparams = extend( extend( {}, QUnit.urlParams ), params );\n\t\tvar key,\n\t\t\tquerystring = \"?\";\n\n\t\tfor ( key in params ) {\n\t\t\tif ( hasOwn.call( params, key ) ) {\n\t\t\t\tquerystring += encodeURIComponent( key ) + \"=\" +\n\t\t\t\t\tencodeURIComponent( params[ key ] ) + \"&\";\n\t\t\t}\n\t\t}\n\t\treturn window.location.protocol + \"//\" + window.location.host +\n\t\t\twindow.location.pathname + querystring.slice( 0, -1 );\n\t},\n\n\textend: extend\n});\n\n/**\n * @deprecated: Created for backwards compatibility with test runner that set the hook function\n * into QUnit.{hook}, instead of invoking it and passing the hook function.\n * QUnit.constructor is set to the empty F() above so that we can add to it's prototype here.\n * Doing this allows us to tell if the following methods have been overwritten on the actual\n * QUnit object.\n */\nextend( QUnit.constructor.prototype, {\n\n\t// Logging callbacks; all receive a single argument with the listed properties\n\t// run test/logs.html for any related changes\n\tbegin: registerLoggingCallback( \"begin\" ),\n\n\t// done: { failed, passed, total, runtime }\n\tdone: registerLoggingCallback( \"done\" ),\n\n\t// log: { result, actual, expected, message }\n\tlog: registerLoggingCallback( \"log\" ),\n\n\t// testStart: { name }\n\ttestStart: registerLoggingCallback( \"testStart\" ),\n\n\t// testDone: { name, failed, passed, total, runtime }\n\ttestDone: registerLoggingCallback( \"testDone\" ),\n\n\t// moduleStart: { name }\n\tmoduleStart: registerLoggingCallback( \"moduleStart\" ),\n\n\t// moduleDone: { name, failed, passed, total }\n\tmoduleDone: registerLoggingCallback( \"moduleDone\" )\n});\n\nQUnit.load = function() {\n\trunLoggingCallbacks( \"begin\", {\n\t\ttotalTests: Test.count\n\t});\n\n\t// Initialize the configuration options\n\textend( config, {\n\t\tstats: { all: 0, bad: 0 },\n\t\tmoduleStats: { all: 0, bad: 0 },\n\t\tstarted: 0,\n\t\tupdateRate: 1000,\n\t\tautostart: true,\n\t\tfilter: \"\",\n\t\tsemaphore: 1\n\t}, true );\n\n\tconfig.blocking = false;\n\n\tif ( config.autostart ) {\n\t\tQUnit.start();\n\t}\n};\n\n// `onErrorFnPrev` initialized at top of scope\n// Preserve other handlers\nonErrorFnPrev = window.onerror;\n\n// Cover uncaught exceptions\n// Returning true will suppress the default browser handler,\n// returning false will let it run.\nwindow.onerror = function( error, filePath, linerNr ) {\n\tvar ret = false;\n\tif ( onErrorFnPrev ) {\n\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t}\n\n\t// Treat return value as window.onerror itself does,\n\t// Only do our handling if not suppressed.\n\tif ( ret !== true ) {\n\t\tif ( QUnit.config.current ) {\n\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t} else {\n\t\t\tQUnit.test( \"global failure\", extend(function() {\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t}, { validTest: validTest } ) );\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn ret;\n};\n\nfunction done() {\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\tname: config.previousModule,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all\n\t\t});\n\t}\n\tdelete config.previousModule;\n\n\tvar runtime = now() - config.started,\n\t\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( \"done\", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t});\n}\n\n/** @return Boolean: true if this test should be ran */\nfunction validTest( test ) {\n\tvar include,\n\t\tfilter = config.filter && config.filter.toLowerCase(),\n\t\tmodule = config.module && config.module.toLowerCase(),\n\t\tfullName = ( test.module + \": \" + test.testName ).toLowerCase();\n\n\t// Internally-generated tests are always valid\n\tif ( test.callback && test.callback.validTest === validTest ) {\n\t\tdelete test.callback.validTest;\n\t\treturn true;\n\t}\n\n\tif ( config.testNumber.length > 0 ) {\n\t\tif ( inArray( test.testNumber, config.testNumber ) < 0 ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif ( module && ( !test.module || test.module.toLowerCase() !== module ) ) {\n\t\treturn false;\n\t}\n\n\tif ( !filter ) {\n\t\treturn true;\n\t}\n\n\tinclude = filter.charAt( 0 ) !== \"!\";\n\tif ( !include ) {\n\t\tfilter = filter.slice( 1 );\n\t}\n\n\t// If the filter matches, we need to honour include\n\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\treturn include;\n\t}\n\n\t// Otherwise, do the opposite\n\treturn !include;\n}\n\n// Doesn't support IE6 to IE9\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stacktrace ) {\n\n\t\t// Opera 12.x\n\t\treturn e.stacktrace.split( \"\\n\" )[ offset + 3 ];\n\t} else if ( e.stack ) {\n\n\t\t// Firefox, Chrome, Safari 6+, IE10+, PhantomJS and Node\n\t\tstack = e.stack.split( \"\\n\" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\t} else if ( e.sourceURL ) {\n\n\t\t// Safari < 6\n\t\t// exclude useless self-reference for generated Error objects\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// for actual exceptions, this is useful\n\t\treturn e.sourceURL + \":\" + e.line;\n\t}\n}\nfunction sourceFromStacktrace( offset ) {\n\ttry {\n\t\tthrow new Error();\n\t} catch ( e ) {\n\t\treturn extractStacktrace( e, offset );\n\t}\n}\n\nfunction synchronize( callback, last ) {\n\tconfig.queue.push( callback );\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = config.depth ? config.depth + 1 : 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 || ( ( now() - start ) < config.updateRate ) ) {\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in window ) {\n\t\t\tif ( hasOwn.call( window, key ) ) {\n\t\t\t\t// in Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\n\t}\n}\n\n// returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\n\t\t\t// Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\n\t\t\tif ( !( prop === \"constructor\" && a === window ) ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction registerLoggingCallback( key ) {\n\n\t// Initialize key collection of logging callback\n\tif ( QUnit.objectType( config.callbacks[ key ] ) === \"undefined\" ) {\n\t\tconfig.callbacks[ key ] = [];\n\t}\n\n\treturn function( callback ) {\n\t\tconfig.callbacks[ key ].push( callback );\n\t};\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n// from jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nfunction Test( settings ) {\n\textend( this, settings );\n\tthis.assert = new Assert( this );\n\tthis.assertions = [];\n\tthis.testNumber = ++Test.count;\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tsetup: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\t\tname: config.previousModule,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all\n\t\t\t\t});\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0 };\n\t\t\trunLoggingCallbacks( \"moduleStart\", {\n\t\t\t\tname: this.module\n\t\t\t});\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tthis.testEnvironment = extend({\n\t\t\tsetup: function() {},\n\t\t\tteardown: function() {}\n\t\t}, this.moduleTestEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( \"testStart\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module,\n\t\t\ttestNumber: this.testNumber\n\t\t});\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t\tif ( config.notrycatch ) {\n\t\t\tthis.testEnvironment.setup.call( this.testEnvironment, this.assert );\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis.testEnvironment.setup.call( this.testEnvironment, this.assert );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( \"Setup failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\t\t}\n\t},\n\trun: function() {\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\tthis.callback.call( this.testEnvironment, this.assert );\n\t\t\tthis.callbackRuntime = now() - this.callbackStarted;\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tthis.callback.call( this.testEnvironment, this.assert );\n\t\t\tthis.callbackRuntime = now() - this.callbackStarted;\n\t\t} catch ( e ) {\n\t\t\tthis.callbackRuntime = now() - this.callbackStarted;\n\n\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" + this.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\t},\n\tteardown: function() {\n\t\tconfig.current = this;\n\t\tif ( config.notrycatch ) {\n\t\t\tif ( typeof this.callbackRuntime === \"undefined\" ) {\n\t\t\t\tthis.callbackRuntime = now() - this.callbackStarted;\n\t\t\t}\n\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment, this.assert );\n\t\t\treturn;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment, this.assert );\n\t\t\t} catch ( e ) {\n\t\t\t\tthis.pushFailure( \"Teardown failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\t\t\t}\n\t\t}\n\t\tcheckPollution();\n\t},\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was not called.\", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" + this.assertions.length + \" were run\", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.\", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"testDone\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestNumber: this.testNumber,\n\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t});\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar bad,\n\t\t\ttest = this;\n\n\t\tfunction run() {\n\t\t\t// each of these can by async\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.setup();\n\t\t\t});\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.run();\n\t\t\t});\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.teardown();\n\t\t\t});\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.finish();\n\t\t\t});\n\t\t}\n\n\t\t// `bad` initialized at top of scope\n\t\t// defer when previous test run passed, if storage is available\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\n\n\t\tif ( bad ) {\n\t\t\trun();\n\t\t} else {\n\t\t\tsynchronize( run, true );\n\t\t}\n\t},\n\n\tpush: function( result, actual, expected, message ) {\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: result,\n\t\t\t\tmessage: message,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\ttestNumber: this.testNumber\n\t\t\t};\n\n\t\tif ( !result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push({\n\t\t\tresult: !!result,\n\t\t\tmessage: message\n\t\t});\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !this instanceof Test ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || \"error\",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestNumber: this.testNumber\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push({\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t});\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current.assert.test;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Exports test.push() to the user API\n\tpush: function() {\n\t\tvar assert = this;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !QUnit.config.current ) {\n\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t}\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = QUnit.config.current.assert;\n\t\t}\n\t\treturn assert.test.push.apply( assert.test, arguments );\n\t},\n\n\t/**\n\t * Asserts rough true-ish result.\n\t * @name ok\n\t * @function\n\t * @example ok( \"asdfasdf\".length > 5, \"There must be at least 5 chars\" );\n\t */\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tif ( !!result ) {\n\t\t\tthis.push( true, result, true, message );\n\t\t} else {\n\t\t\tthis.test.pushFailure( message, null, result );\n\t\t}\n\t},\n\n\t/**\n\t * Assert that the first two arguments are equal, with an optional message.\n\t * Prints out both actual and expected values.\n\t * @name equal\n\t * @function\n\t * @example equal( format( \"Received {0} bytes.\", 2), \"Received 2 bytes.\", \"format() replaces {0} with next argument\" );\n\t */\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push( expected == actual, actual, expected, message );\n\t},\n\n\t/**\n\t * @name notEqual\n\t * @function\n\t */\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push( expected != actual, actual, expected, message );\n\t},\n\n\t/**\n\t * @name propEqual\n\t * @function\n\t */\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\t/**\n\t * @name notPropEqual\n\t * @function\n\t */\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\t/**\n\t * @name deepEqual\n\t * @function\n\t */\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\t/**\n\t * @name notDeepEqual\n\t * @function\n\t */\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\t/**\n\t * @name strictEqual\n\t * @function\n\t */\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.push( expected === actual, actual, expected, message );\n\t},\n\n\t/**\n\t * @name notStrictEqual\n\t * @function\n\t */\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.push( expected !== actual, actual, expected, message );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false;\n\n\t\t// 'expected' is optional unless doing string comparison\n\t\tif ( message == null && typeof expected === \"string\" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tthis.test.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( this.test.testEnvironment );\n\t\t} catch (e) {\n\t\t\tactual = e;\n\t\t}\n\t\tthis.test.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// we don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// expected is a regexp\n\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// expected is a string\n\t\t\t} else if ( expectedType === \"string\" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// expected is an Error object\n\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\n\t\t\tthis.push( ok, actual, expectedOutput, message );\n\t\t} else {\n\t\t\tthis.test.pushFailure( message, null, \"No exception was thrown.\" );\n\t\t}\n\t}\n};\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = (function() {\n\n\t// Call the o related callback with the given arguments.\n\tfunction bindCallbacks( o, callbacks, args ) {\n\t\tvar prop = QUnit.objectType( o );\n\t\tif ( prop ) {\n\t\t\tif ( QUnit.objectType( callbacks[ prop ] ) === \"function\" ) {\n\t\t\t\treturn callbacks[ prop ].apply( callbacks, args );\n\t\t\t} else {\n\t\t\t\treturn callbacks[ prop ]; // or undefined\n\t\t\t}\n\t\t}\n\t}\n\n\t// the real equiv function\n\tvar innerEquiv,\n\n\t\t// stack to decide between skip/abort functions\n\t\tcallers = [],\n\n\t\t// stack to avoiding loops from circular referencing\n\t\tparents = [],\n\t\tparentsB = [],\n\n\t\tgetProto = Object.getPrototypeOf || function( obj ) {\n\t\t\t/* jshint camelcase: false, proto: true */\n\t\t\treturn obj.__proto__;\n\t\t},\n\t\tcallbacks = (function() {\n\n\t\t\t// for string, boolean, number and null\n\t\t\tfunction useStrictEquality( b, a ) {\n\n\t\t\t\t/*jshint eqeqeq:false */\n\t\t\t\tif ( b instanceof a.constructor || a instanceof b.constructor ) {\n\n\t\t\t\t\t// to catch short annotation VS 'new' annotation of a\n\t\t\t\t\t// declaration\n\t\t\t\t\t// e.g. var i = 1;\n\t\t\t\t\t// var j = new Number(1);\n\t\t\t\t\treturn a == b;\n\t\t\t\t} else {\n\t\t\t\t\treturn a === b;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t\"string\": useStrictEquality,\n\t\t\t\t\"boolean\": useStrictEquality,\n\t\t\t\t\"number\": useStrictEquality,\n\t\t\t\t\"null\": useStrictEquality,\n\t\t\t\t\"undefined\": useStrictEquality,\n\n\t\t\t\t\"nan\": function( b ) {\n\t\t\t\t\treturn isNaN( b );\n\t\t\t\t},\n\n\t\t\t\t\"date\": function( b, a ) {\n\t\t\t\t\treturn QUnit.objectType( b ) === \"date\" && a.valueOf() === b.valueOf();\n\t\t\t\t},\n\n\t\t\t\t\"regexp\": function( b, a ) {\n\t\t\t\t\treturn QUnit.objectType( b ) === \"regexp\" &&\n\n\t\t\t\t\t\t// the regex itself\n\t\t\t\t\t\ta.source === b.source &&\n\n\t\t\t\t\t\t// and its modifiers\n\t\t\t\t\t\ta.global === b.global &&\n\n\t\t\t\t\t\t// (gmi) ...\n\t\t\t\t\t\ta.ignoreCase === b.ignoreCase &&\n\t\t\t\t\t\ta.multiline === b.multiline &&\n\t\t\t\t\t\ta.sticky === b.sticky;\n\t\t\t\t},\n\n\t\t\t\t// - skip when the property is a method of an instance (OOP)\n\t\t\t\t// - abort otherwise,\n\t\t\t\t// initial === would have catch identical references anyway\n\t\t\t\t\"function\": function() {\n\t\t\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t\t\t},\n\n\t\t\t\t\"array\": function( b, a ) {\n\t\t\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\t\t\t// b could be an object literal here\n\t\t\t\t\tif ( QUnit.objectType( b ) !== \"array\" ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen = a.length;\n\t\t\t\t\tif ( len !== b.length ) {\n\t\t\t\t\t\t// safe and faster\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\tparents.push( a );\n\t\t\t\t\tparentsB.push( b );\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t\"object\": function( b, a ) {\n\n\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\tvar i, j, loop, aCircular, bCircular,\n\t\t\t\t\t\t// Default to true\n\t\t\t\t\t\teq = true,\n\t\t\t\t\t\taProperties = [],\n\t\t\t\t\t\tbProperties = [];\n\n\t\t\t\t\t// comparing constructors is more strict than using\n\t\t\t\t\t// instanceof\n\t\t\t\t\tif ( a.constructor !== b.constructor ) {\n\n\t\t\t\t\t\t// Allow objects with no prototype to be equivalent to\n\t\t\t\t\t\t// objects with Object as their constructor.\n\t\t\t\t\t\tif ( !( ( getProto( a ) === null && getProto( b ) === Object.prototype ) ||\n\t\t\t\t\t\t\t( getProto( b ) === null && getProto( a ) === Object.prototype ) ) ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// stack constructor before traversing properties\n\t\t\t\t\tcallers.push( a.constructor );\n\n\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\tparents.push( a );\n\t\t\t\t\tparentsB.push( b );\n\n\t\t\t\t\t// be strict: don't ensure hasOwnProperty and go deep\n\t\t\t\t\tfor ( i in a ) {\n\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\taProperties.push( i );\n\t\t\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\tcallers.pop(); // unstack, we are done\n\n\t\t\t\t\tfor ( i in b ) {\n\t\t\t\t\t\tbProperties.push( i ); // collect b's properties\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensures identical properties name\n\t\t\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t\t\t}\n\t\t\t};\n\t\t}());\n\n\tinnerEquiv = function() { // can take multiple arguments\n\t\tvar args = [].slice.apply( arguments );\n\t\tif ( args.length < 2 ) {\n\t\t\treturn true; // end transition\n\t\t}\n\n\t\treturn ( (function( a, b ) {\n\t\t\tif ( a === b ) {\n\t\t\t\treturn true; // catch the most you can\n\t\t\t} else if ( a === null || b === null || typeof a === \"undefined\" ||\n\t\t\t\t\ttypeof b === \"undefined\" ||\n\t\t\t\t\tQUnit.objectType( a ) !== QUnit.objectType( b ) ) {\n\n\t\t\t\t// don't lose time with error prone cases\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn bindCallbacks( a, callbacks, [ b, a ] );\n\t\t\t}\n\n\t\t\t// apply transition with (1..n) arguments\n\t\t}( args[ 0 ], args[ 1 ] ) ) && innerEquiv.apply( this, args.splice( 1, args.length - 1 ) ) );\n\t};\n\n\treturn innerEquiv;\n}());\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = (function() {\n\tfunction quote( str ) {\n\t\treturn \"\\\"\" + str.toString().replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + \"\";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( \"[\", ret, \"]\" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\t\t\t// type is used mostly internally, you can fix a (custom)type in advance\n\t\t\tparse: function( obj, type, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar inStack, res,\n\t\t\t\t\tparser = this.parsers[ type || this.typeOf( obj ) ];\n\n\t\t\t\ttype = typeof parser;\n\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn \"recursion(\" + ( inStack - stack.length ) + \")\";\n\t\t\t\t}\n\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( type === \"string\" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = \"null\";\n\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t} else if ( QUnit.is( \"regexp\", obj ) ) {\n\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t} else if ( QUnit.is( \"date\", obj ) ) {\n\t\t\t\t\ttype = \"date\";\n\t\t\t\t} else if ( QUnit.is( \"function\", obj ) ) {\n\t\t\t\t\ttype = \"function\";\n\t\t\t\t} else if ( typeof obj.setInterval !== undefined && typeof obj.document !== \"undefined\" && typeof obj.nodeType === \"undefined\" ) {\n\t\t\t\t\ttype = \"window\";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = \"document\";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = \"node\";\n\t\t\t\t} else if (\n\n\t\t\t\t\t// native arrays\n\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === \"number\" && typeof obj.item !== \"undefined\" && ( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null && typeof obj[ 0 ] === \"undefined\" ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = \"array\";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = \"error\";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&nbsp;\" : \" \";\n\t\t\t},\n\t\t\t// extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&nbsp;\" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\t//\n\t\t\tdepth: 1,\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: \"[Window]\",\n\t\t\t\tdocument: \"[Document]\",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t},\n\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\"null\": \"null\",\n\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\tvar ret = \"function\",\n\t\t\t\t\t\t// functions never have name in IE\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += \"( \";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t\"arguments\": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\tvar ret = [], keys, key, val, i, nonEnumerableProperties;\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ \"message\", \"name\" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && !( key in keys ) ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, \"key\" ) + \": \" + dump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\tclose = dump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly set.\n\t\t\t\t\t\t\t// Those have values like undefined, null, 0, false, \"\" or \"inherit\".\n\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\tret += \" \" + attrs[ i ].nodeName + \"=\" + dump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// function calls it internally, it's the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t},\n\t\t\t\t// object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\t\t\t\t// function calls it internally, it's the content of the function\n\t\t\t\tfunctionCode: \"[code]\",\n\t\t\t\t// node calls it internally, it's an html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t\"boolean\": literal\n\t\t\t},\n\t\t\t// if true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\t\t\t// indentation unit\n\t\t\tindentChar: \"  \",\n\t\t\t// if true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}());\n\n// back compat\nQUnit.jsDump = QUnit.dump;\n\n// For browser, export only select globals\nif ( typeof window !== \"undefined\" ) {\n\n\t// Deprecated\n\t// Extend assert methods to QUnit and Global scope through Backwards compatibility\n\t(function() {\n\t\tvar i,\n\t\t\tassertions = Assert.prototype;\n\n\t\tfunction applyCurrent( current ) {\n\t\t\treturn function() {\n\t\t\t\tvar assert = new Assert( QUnit.config.current );\n\t\t\t\tcurrent.apply( assert, arguments );\n\t\t\t};\n\t\t}\n\n\t\tfor ( i in assertions ) {\n\t\t\tQUnit[ i ] = applyCurrent( assertions[ i ] );\n\t\t}\n\t})();\n\n\t(function() {\n\t\tvar i, l,\n\t\t\tkeys = [\n\t\t\t\t\"test\",\n\t\t\t\t\"module\",\n\t\t\t\t\"expect\",\n\t\t\t\t\"asyncTest\",\n\t\t\t\t\"start\",\n\t\t\t\t\"stop\",\n\t\t\t\t\"ok\",\n\t\t\t\t\"equal\",\n\t\t\t\t\"notEqual\",\n\t\t\t\t\"propEqual\",\n\t\t\t\t\"notPropEqual\",\n\t\t\t\t\"deepEqual\",\n\t\t\t\t\"notDeepEqual\",\n\t\t\t\t\"strictEqual\",\n\t\t\t\t\"notStrictEqual\",\n\t\t\t\t\"throws\"\n\t\t\t];\n\n\t\tfor ( i = 0, l = keys.length; i < l; i++ ) {\n\t\t\twindow[ keys[ i ] ] = QUnit[ keys[ i ] ];\n\t\t}\n\t})();\n\n\twindow.QUnit = QUnit;\n}\n\n// For CommonJS environments, export everything\nif ( typeof module !== \"undefined\" && module.exports ) {\n\tmodule.exports = QUnit;\n}\n\n// Get a reference to the global object, like window in browsers\n}( (function() {\n\treturn this;\n})() ));\n\n/*istanbul ignore next */\n/*\n * Javascript Diff Algorithm\n *  By John Resig (http://ejohn.org/)\n *  Modified by Chu Alan \"sprite\"\n *\n * Released under the MIT license.\n *\n * More Info:\n *  http://ejohn.org/projects/javascript-diff-algorithm/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n * QUnit.diff( \"the quick brown fox jumped over\", \"the quick fox jumps over\" ) == \"the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over\"\n */\nQUnit.diff = (function() {\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\n\t/*jshint eqeqeq:false, eqnull:true */\n\tfunction diff( o, n ) {\n\t\tvar i,\n\t\t\tns = {},\n\t\t\tos = {};\n\n\t\tfor ( i = 0; i < n.length; i++ ) {\n\t\t\tif ( !hasOwn.call( ns, n[ i ] ) ) {\n\t\t\t\tns[ n[ i ] ] = {\n\t\t\t\t\trows: [],\n\t\t\t\t\to: null\n\t\t\t\t};\n\t\t\t}\n\t\t\tns[ n[ i ] ].rows.push( i );\n\t\t}\n\n\t\tfor ( i = 0; i < o.length; i++ ) {\n\t\t\tif ( !hasOwn.call( os, o[ i ] ) ) {\n\t\t\t\tos[ o[ i ] ] = {\n\t\t\t\t\trows: [],\n\t\t\t\t\tn: null\n\t\t\t\t};\n\t\t\t}\n\t\t\tos[ o[ i ] ].rows.push( i );\n\t\t}\n\n\t\tfor ( i in ns ) {\n\t\t\tif ( hasOwn.call( ns, i ) ) {\n\t\t\t\tif ( ns[ i ].rows.length === 1 && hasOwn.call( os, i ) && os[ i ].rows.length === 1 ) {\n\t\t\t\t\tn[ ns[ i ].rows[ 0 ] ] = {\n\t\t\t\t\t\ttext: n[ ns[ i ].rows[ 0 ] ],\n\t\t\t\t\t\trow: os[ i ].rows[ 0 ]\n\t\t\t\t\t};\n\t\t\t\t\to[ os[ i ].rows[ 0 ] ] = {\n\t\t\t\t\t\ttext: o[ os[ i ].rows[ 0 ] ],\n\t\t\t\t\t\trow: ns[ i ].rows[ 0 ]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor ( i = 0; i < n.length - 1; i++ ) {\n\t\t\tif ( n[ i ].text != null && n[ i + 1 ].text == null && n[ i ].row + 1 < o.length && o[ n[ i ].row + 1 ].text == null &&\n\t\t\t\tn[ i + 1 ] == o[ n[ i ].row + 1 ] ) {\n\n\t\t\t\tn[ i + 1 ] = {\n\t\t\t\t\ttext: n[ i + 1 ],\n\t\t\t\t\trow: n[ i ].row + 1\n\t\t\t\t};\n\t\t\t\to[ n[ i ].row + 1 ] = {\n\t\t\t\t\ttext: o[ n[ i ].row + 1 ],\n\t\t\t\t\trow: i + 1\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tfor ( i = n.length - 1; i > 0; i-- ) {\n\t\t\tif ( n[ i ].text != null && n[ i - 1 ].text == null && n[ i ].row > 0 && o[ n[ i ].row - 1 ].text == null &&\n\t\t\t\tn[ i - 1 ] == o[ n[ i ].row - 1 ] ) {\n\n\t\t\t\tn[ i - 1 ] = {\n\t\t\t\t\ttext: n[ i - 1 ],\n\t\t\t\t\trow: n[ i ].row - 1\n\t\t\t\t};\n\t\t\t\to[ n[ i ].row - 1 ] = {\n\t\t\t\t\ttext: o[ n[ i ].row - 1 ],\n\t\t\t\t\trow: i - 1\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\to: o,\n\t\t\tn: n\n\t\t};\n\t}\n\n\treturn function( o, n ) {\n\t\to = o.replace( /\\s+$/, \"\" );\n\t\tn = n.replace( /\\s+$/, \"\" );\n\n\t\tvar i, pre,\n\t\t\tstr = \"\",\n\t\t\tout = diff( o === \"\" ? [] : o.split( /\\s+/ ), n === \"\" ? [] : n.split( /\\s+/ ) ),\n\t\t\toSpace = o.match( /\\s+/g ),\n\t\t\tnSpace = n.match( /\\s+/g );\n\n\t\tif ( oSpace == null ) {\n\t\t\toSpace = [ \" \" ];\n\t\t} else {\n\t\t\toSpace.push( \" \" );\n\t\t}\n\n\t\tif ( nSpace == null ) {\n\t\t\tnSpace = [ \" \" ];\n\t\t} else {\n\t\t\tnSpace.push( \" \" );\n\t\t}\n\n\t\tif ( out.n.length === 0 ) {\n\t\t\tfor ( i = 0; i < out.o.length; i++ ) {\n\t\t\t\tstr += \"<del>\" + out.o[ i ] + oSpace[ i ] + \"</del>\";\n\t\t\t}\n\t\t} else {\n\t\t\tif ( out.n[ 0 ].text == null ) {\n\t\t\t\tfor ( n = 0; n < out.o.length && out.o[ n ].text == null; n++ ) {\n\t\t\t\t\tstr += \"<del>\" + out.o[ n ] + oSpace[ n ] + \"</del>\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < out.n.length; i++ ) {\n\t\t\t\tif ( out.n[ i ].text == null ) {\n\t\t\t\t\tstr += \"<ins>\" + out.n[ i ] + nSpace[ i ] + \"</ins>\";\n\t\t\t\t} else {\n\n\t\t\t\t\t// `pre` initialized at top of scope\n\t\t\t\t\tpre = \"\";\n\n\t\t\t\t\tfor ( n = out.n[ i ].row + 1; n < out.o.length && out.o[ n ].text == null; n++ ) {\n\t\t\t\t\t\tpre += \"<del>\" + out.o[ n ] + oSpace[ n ] + \"</del>\";\n\t\t\t\t\t}\n\t\t\t\t\tstr += \" \" + out.n[ i ].text + nSpace[ i ] + pre;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn str;\n\t};\n}());\n\n(function() {\n\n// Deprecated QUnit.init - Ref #530\n// Re-initialize the configuration options\nQUnit.init = function() {\n\tvar tests, banner, result, qunit,\n\t\tconfig = QUnit.config;\n\n\tconfig.stats = { all: 0, bad: 0 };\n\tconfig.moduleStats = { all: 0, bad: 0 };\n\tconfig.started = 0;\n\tconfig.updateRate = 1000;\n\tconfig.blocking = false;\n\tconfig.autostart = true;\n\tconfig.autorun = false;\n\tconfig.filter = \"\";\n\tconfig.queue = [];\n\tconfig.semaphore = 1;\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( typeof window === \"undefined\" ) {\n\t\treturn;\n\t}\n\n\tqunit = id( \"qunit\" );\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t}\n\n\ttests = id( \"qunit-tests\" );\n\tbanner = id( \"qunit-banner\" );\n\tresult = id( \"qunit-testresult\" );\n\n\tif ( tests ) {\n\t\ttests.innerHTML = \"\";\n\t}\n\n\tif ( banner ) {\n\t\tbanner.className = \"\";\n\t}\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\tresult = document.createElement( \"p\" );\n\t\tresult.id = \"qunit-testresult\";\n\t\tresult.className = \"result\";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = \"Running...<br/>&nbsp;\";\n\t}\n};\n\n// Resets the test setup. Useful for tests that modify the DOM.\n/*\nDEPRECATED: Use multiple tests instead of resetting inside a test.\nUse testStart or testDone for custom cleanup.\nThis method will throw an error in 2.0, and will be removed in 2.1\n*/\nQUnit.reset = function() {\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( typeof window === \"undefined\" ) {\n\t\treturn;\n\t}\n\n\tvar fixture = id( \"qunit-fixture\" );\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n};\n\n// Don't load the HTML Reporter on non-Browser environments\nif ( typeof window === \"undefined\" ) {\n\treturn;\n}\n\nvar config = QUnit.config,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tdefined = {\n\t\tdocument: typeof window.document !== \"undefined\",\n\t\tsessionStorage: (function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}())\n\t};\n\n/**\n* Escape text for attribute or text content.\n*/\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn \"\";\n\t}\n\ts = s + \"\";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase \"'\":\n\t\t\treturn \"&#039;\";\n\t\tcase \"\\\"\":\n\t\t\treturn \"&quot;\";\n\t\tcase \"<\":\n\t\t\treturn \"&lt;\";\n\t\tcase \">\":\n\t\t\treturn \"&gt;\";\n\t\tcase \"&\":\n\t\t\treturn \"&amp;\";\n\t\t}\n\t});\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n\tif ( elem.addEventListener ) {\n\n\t\t// Standards-based browsers\n\t\telem.addEventListener( type, fn, false );\n\t} else if ( elem.attachEvent ) {\n\n\t\t// support: IE <9\n\t\telem.attachEvent( \"on\" + type, fn );\n\t}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? \" \" : \"\" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name ) {\n\tif ( hasClass( elem, name ) ) {\n\t\tremoveClass( elem, name );\n\t} else {\n\t\taddClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = \" \" + elem.className + \" \";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {\n\t\tset = set.replace( \" \" + name + \" \", \" \" );\n\t}\n\n\t// trim for prettiness\n\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );\n}\n\nfunction id( name ) {\n\treturn defined.document && document.getElementById && document.getElementById( name );\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\tlen = config.urlConfig.length,\n\t\turlConfigHtml = \"\";\n\n\tfor ( i = 0; i < len; i++ ) {\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === \"string\" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tconfig[ val.id ] = QUnit.urlParams[ val.id ];\n\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' type='checkbox'\" +\n\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\" title='\" + escapedTooltip + \"'><label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label + \"</label>\";\n\t\t} else {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label +\n\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\n\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\">\" + escaped + \"</option>\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[ j ] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += \"<option value='\" + escaped +\n\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\n\t\t\t}\n\t\t\turlConfigHtml += \"</select>\";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( \"span\" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\n\t// For oldIE support:\n\t// * Add handlers to the individual elements instead of the container\n\t// * Use \"click\" instead of \"change\" for checkboxes\n\t// * Fallback from event.target to event.srcElement\n\taddEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"click\", function( event ) {\n\t\tvar params = {},\n\t\t\ttarget = event.target || event.srcElement;\n\t\tparams[ target.name ] = target.checked ?\n\t\t\ttarget.defaultValue || true :\n\t\t\tundefined;\n\t\twindow.location = QUnit.url( params );\n\t});\n\taddEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", function( event ) {\n\t\tvar params = {},\n\t\t\ttarget = event.target || event.srcElement;\n\t\tparams[ target.name ] = target.options[ target.selectedIndex ].value || undefined;\n\t\twindow.location = QUnit.url( params );\n\t});\n\n\treturn urlConfigContainer;\n}\n\nfunction getModuleNames() {\n\tvar i,\n\t\tmoduleNames = [];\n\n\tfor ( i in config.modules ) {\n\t\tif ( config.modules.hasOwnProperty( i ) ) {\n\t\t\tmoduleNames.push( i );\n\t\t}\n\t}\n\n\tmoduleNames.sort(function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t});\n\n\treturn moduleNames;\n}\n\nfunction toolbarModuleFilterHtml() {\n\tvar i,\n\t\tmoduleFilterHtml = \"\",\n\t\tmoduleNames = getModuleNames();\n\n\tif ( moduleNames.length <= 1 ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label>\" +\n\t\t\"<select id='qunit-modulefilter' name='modulefilter'><option value='' \" +\n\t\t( config.module === undefined ? \"selected='selected'\" : \"\" ) +\n\t\t\">< All Modules ></option>\";\n\n\tfor ( i = 0; i < moduleNames.length; i++ ) {\n\t\tmoduleFilterHtml += \"<option value='\" +\n\t\t\tescapeText( encodeURIComponent( moduleNames[ i ] ) ) + \"' \" +\n\t\t\t( config.module === moduleNames[ i ] ? \"selected='selected'\" : \"\" ) +\n\t\t\t\">\" + escapeText( moduleNames[ i ] ) + \"</option>\";\n\t}\n\tmoduleFilterHtml += \"</select>\";\n\n\treturn moduleFilterHtml;\n}\n\nfunction toolbarModuleFilter() {\n\tvar moduleFilter = document.createElement( \"span\" ),\n\t\tmoduleFilterHtml = toolbarModuleFilterHtml();\n\n\tif ( !moduleFilterHtml ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilter.setAttribute( \"id\", \"qunit-modulefilter-container\" );\n\tmoduleFilter.innerHTML = moduleFilterHtml;\n\n\taddEvent( moduleFilter.lastChild, \"change\", function() {\n\t\tvar selectBox = moduleFilter.getElementsByTagName( \"select\" )[ 0 ],\n\t\t\tselectedModule = decodeURIComponent( selectBox.options[ selectBox.selectedIndex ].value );\n\n\t\twindow.location = QUnit.url({\n\t\t\tmodule: ( selectedModule === \"\" ) ? undefined : selectedModule,\n\n\t\t\t// Remove any existing filters\n\t\t\tfilter: undefined,\n\t\t\ttestNumber: undefined\n\t\t});\n\t});\n\n\treturn moduleFilter;\n}\n\nfunction toolbarFilter() {\n\tvar testList = id( \"qunit-tests\" ),\n\t\tfilter = document.createElement( \"input\" );\n\n\tfilter.type = \"checkbox\";\n\tfilter.id = \"qunit-filter-pass\";\n\n\taddEvent( filter, \"click\", function() {\n\t\tif ( filter.checked ) {\n\t\t\taddClass( testList, \"hidepass\" );\n\t\t\tif ( defined.sessionStorage ) {\n\t\t\t\tsessionStorage.setItem( \"qunit-filter-passed-tests\", \"true\" );\n\t\t\t}\n\t\t} else {\n\t\t\tremoveClass( testList, \"hidepass\" );\n\t\t\tif ( defined.sessionStorage ) {\n\t\t\t\tsessionStorage.removeItem( \"qunit-filter-passed-tests\" );\n\t\t\t}\n\t\t}\n\t});\n\n\tif ( config.hidepassed || defined.sessionStorage &&\n\t\t\tsessionStorage.getItem( \"qunit-filter-passed-tests\" ) ) {\n\t\tfilter.checked = true;\n\n\t\taddClass( testList, \"hidepass\" );\n\t}\n\n\treturn filter;\n}\n\nfunction toolbarLabel() {\n\tvar label = document.createElement( \"label\" );\n\tlabel.setAttribute( \"for\", \"qunit-filter-pass\" );\n\tlabel.setAttribute( \"title\", \"Only show tests and assertions that fail. Stored in sessionStorage.\" );\n\tlabel.innerHTML = \"Hide passed tests\";\n\n\treturn label;\n}\n\nfunction appendToolbar() {\n\tvar moduleFilter,\n\t\ttoolbar = id( \"qunit-testrunner-toolbar\" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarFilter() );\n\t\ttoolbar.appendChild( toolbarLabel() );\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\n\t\tmoduleFilter = toolbarModuleFilter();\n\t\tif ( moduleFilter ) {\n\t\t\ttoolbar.appendChild( moduleFilter );\n\t\t}\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( \"qunit-banner\" );\n\n\tif ( banner ) {\n\t\tbanner.className = \"\";\n\t\tbanner.innerHTML = \"<a href='\" +\n\t\t\tQUnit.url({ filter: undefined, module: undefined, testNumber: undefined }) +\n\t\t\t\"'>\" + banner.innerHTML + \"</a> \";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( \"qunit-tests\" ),\n\t\tresult = id( \"qunit-testresult\" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = \"\";\n\t\tresult = document.createElement( \"p\" );\n\t\tresult.id = \"qunit-testresult\";\n\t\tresult.className = \"result\";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = \"Running...<br>&nbsp;\";\n\t}\n}\n\nfunction storeFixture() {\n\tvar fixture = id( \"qunit-fixture\" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( \"qunit-userAgent\" );\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = navigator.userAgent;\n\t}\n}\n\n// HTML Reporter initialization and load\nQUnit.begin(function() {\n\tvar qunit = id( \"qunit\" );\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\"<ol id='qunit-tests'></ol>\";\n\t}\n\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n\tstoreFixture();\n});\n\nQUnit.done(function( details ) {\n\tvar i, key,\n\t\tbanner = id( \"qunit-banner\" ),\n\t\ttests = id( \"qunit-tests\" ),\n\t\thtml = [\n\t\t\t\"Tests completed in \",\n\t\t\tdetails.runtime,\n\t\t\t\" milliseconds.<br>\",\n\t\t\t\"<span class='passed'>\",\n\t\t\tdetails.passed,\n\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\tdetails.total,\n\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\tdetails.failed,\n\t\t\t\"</span> failed.\"\n\t\t].join( \"\" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\n\t}\n\n\tif ( tests ) {\n\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && defined.document && document.title ) {\n\n\t\t// show ✖ for good, ✔ for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t].join( \" \" );\n\t}\n\n\t// clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n});\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = \"\";\n\n\tif ( module ) {\n\t\tnameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";\n\t}\n\n\tnameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart(function( details ) {\n\tvar a, b, li, running, assertList,\n\t\tname = getNameHtml( details.name, details.module ),\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( tests ) {\n\t\tb = document.createElement( \"strong\" );\n\t\tb.innerHTML = name;\n\n\t\ta = document.createElement( \"a\" );\n\t\ta.innerHTML = \"Rerun\";\n\t\ta.href = QUnit.url({ testNumber: details.testNumber });\n\n\t\tli = document.createElement( \"li\" );\n\t\tli.appendChild( b );\n\t\tli.appendChild( a );\n\t\tli.className = \"running\";\n\t\tli.id = \"qunit-test-output\" + details.testNumber;\n\n\t\tassertList = document.createElement( \"ol\" );\n\t\tassertList.className = \"qunit-assert-list\";\n\n\t\tli.appendChild( assertList );\n\n\t\ttests.appendChild( li );\n\t}\n\n\trunning = id( \"qunit-testresult\" );\n\tif ( running ) {\n\t\trunning.innerHTML = \"Running: <br>\" + name;\n\t}\n\n});\n\nQUnit.log(function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual,\n\t\ttestItem = id( \"qunit-test-output\" + details.testNumber );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );\n\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\n\t// pushFailure doesn't provide details.expected\n\t// when it calls, it's implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, \"expected\" ) ) {\n\t\texpected = escapeText( QUnit.dump.parse( details.expected ) );\n\t\tactual = escapeText( QUnit.dump.parse( details.actual ) );\n\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +\n\t\t\texpected +\n\t\t\t\"</pre></td></tr>\";\n\n\t\tif ( actual !== expected ) {\n\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +\n\t\t\t\tactual + \"</pre></td></tr>\" +\n\t\t\t\t\"<tr class='test-diff'><th>Diff: </th><td><pre>\" +\n\t\t\t\tQUnit.diff( expected, actual ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\tmessage += \"</table>\";\n\n\t// this occours when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += \"<table>\" +\n\t\t\t\"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\tescapeText( details.source ) + \"</pre></td></tr>\" +\n\t\t\t\"</table>\";\n\t}\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tassertLi = document.createElement( \"li\" );\n\tassertLi.className = details.result ? \"pass\" : \"fail\";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n});\n\nQUnit.testDone(function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts,\n\t\ttests = id( \"qunit-tests\" );\n\n\t// QUnit.reset() is deprecated and will be replaced for a new\n\t// fixture reset function on QUnit 2.0/2.1.\n\t// It's still called here for backwards compatibility handling\n\tQUnit.reset();\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( \"qunit-test-output\" + details.testNumber );\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t}\n\n\t// testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t\"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :\n\t\t\"\";\n\n\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts +\n\t\tdetails.assertions.length + \")</b>\";\n\n\taddEvent( testTitle, \"click\", function() {\n\t\ttoggleClass( assertList, \"qunit-collapsed\" );\n\t});\n\n\ttime = document.createElement( \"span\" );\n\ttime.className = \"runtime\";\n\ttime.innerHTML = details.runtime + \" ms\";\n\n\ttestItem.className = bad ? \"fail\" : \"pass\";\n\n\ttestItem.insertBefore( time, assertList );\n});\n\nif ( !defined.document || document.readyState === \"complete\" ) {\n\tconfig.autorun = true;\n}\n\nif ( defined.document ) {\n\taddEvent( window, \"load\", QUnit.load );\n}\n\n})();\n","QUnit.notifications = function(options) {\n  \"use strict\";\n\n  options         = options         || {};\n  options.icons   = options.icons   || {};\n  options.timeout = options.timeout || 4000;\n  options.titles  = options.titles  || { passed: \"Passed!\", failed: \"Failed!\" };\n  options.bodies  = options.bodies  || {\n    passed: \"{{passed}} of {{total}} passed\",\n    failed: \"{{passed}} passed. {{failed}} failed.\"\n  };\n\n  var renderBody = function(body, details) {\n    [ \"passed\", \"failed\", \"total\", \"runtime\" ].forEach(function(type) {\n      body = body.replace(\"{{\" + type + \"}}\", details[ type ]);\n    });\n\n    return body;\n  };\n\n  function generateQueryString(params) {\n    var key,\n      querystring = \"?\";\n\n    params = QUnit.extend(QUnit.extend({}, QUnit.urlParams), params);\n\n    for (key in params) {\n      if (params.hasOwnProperty(key)) {\n        if (params[ key ] === undefined) {\n          continue;\n        }\n        querystring += encodeURIComponent(key);\n        if (params[ key ] !== true) {\n          querystring += \"=\" + encodeURIComponent(params[ key ]);\n        }\n        querystring += \"&\";\n      }\n    }\n    return location.protocol + \"//\" + location.host +\n      location.pathname + querystring.slice(0, -1);\n  }\n\n  if (window.Notification) {\n    QUnit.done(function(details) {\n      var title,\n          _options = {},\n          notification;\n\n      if (window.Notification && QUnit.urlParams.notifications) {\n        if (details.failed === 0) {\n          title = options.titles.passed;\n          _options.body = renderBody(options.bodies.passed, details);\n\n          if (options.icons.passed) {\n            _options.icon = options.icons.passed;\n          }\n        } else {\n          title = options.titles.failed;\n          _options.body = renderBody(options.bodies.failed, details);\n\n          if (options.icons.failed) {\n            _options.icon = options.icons.failed;\n          }\n        }\n\n        notification = new window.Notification(title, _options);\n\n        setTimeout(function() {\n          notification.close();\n        }, options.timeout);\n      }\n    });\n\n    QUnit.begin(function() {\n      var toolbar      = document.getElementById( \"qunit-testrunner-toolbar\" ),\n          notification = document.createElement( \"input\" ),\n          label        = document.createElement(\"label\");\n\n      notification.type = \"checkbox\";\n      notification.id   = \"qunit-notifications\";\n\n      if (QUnit.urlParams.notifications) {\n        notification.checked = true;\n      }\n\n      notification.addEventListener(\"click\", function(event) {\n        if (event.target.checked) {\n          window.Notification.requestPermission(function() {\n            window.location = generateQueryString({ notifications: true });\n          });\n        } else {\n          window.location = generateQueryString({ notifications: undefined });\n        }\n      }, false);\n      toolbar.appendChild(notification);\n\n      label.innerHTML = \"Notifications\";\n      label.setAttribute( \"for\", \"qunit-notifications\" );\n      label.setAttribute( \"title\", \"Show notifications.\" );\n      toolbar.appendChild(label);\n    });\n  }\n};\n","/* jshint node:true, browser:true, undef:true */\n/* global QUnit, QUNIT_BDD_OPTIONS  */\n\n;(function(global, exports, QUnit, options) {\n  if (!QUnit) {\n    throw new Error('Unable to locate QUnit! Please load it before qunit-bdd.');\n  }\n\n  /**\n   * Represents an execution context for tests created by calls to `describe`\n   * and `context`. Contexts can be nested inside each other.\n   *\n   * @class\n   * @private\n   * @param {string} description\n   * @param {?Context} parent\n   * @param {?object} options\n   */\n  function Context(description, parent, options) {\n    this.description = description;\n    this.parent = parent;\n    this.skipped = (options && options.skipped) || (parent && parent.skipped);\n    this.tests = [];\n    this.before = [];\n    this.after = [];\n    this.lazySetup = [];\n    this.lazyTeardown = [];\n  }\n\n  /**\n   * Gets the full context description by prepending any parent context\n   * descriptions joined by a space.\n   *\n   * @return {string}\n   */\n  Context.prototype.fullDescription = function() {\n    if (this.parent) {\n      var parentDescription = this.parent.fullDescription();\n      if (parentDescription) {\n        return parentDescription + ' ' + this.description;\n      }\n    }\n    return this.description;\n  };\n\n  /**\n   * Queues the named hook in the given direction using the given execution\n   * environment. This is used to set up `lazy` values, run `before` and\n   * `after` callbacks, and tear down `lazy` values.\n   *\n   * See `addTestsToQUnit` for an explanation of how QUnit's queue is used to\n   * handle these hooks and async.\n   *\n   * @private\n   * @param {string} hook The name of the hook, such as \"before\".\n   * @param {up} boolean true to run from inside-out, false to run outside-in.\n   * @param {object} env `this` inside the hook callback functions.\n   */\n  Context.prototype.prependHook = function(hook, up, env) {\n    var queue = [];\n    var parent = this.parent;\n\n    this[hook].forEach(function(fn) {\n      queue.push(function() {\n        if (QUnit.config.notrycatch) {\n          fn.call(env);\n        } else {\n          try {\n            fn.call(env);\n          } catch (e) {\n            QUnit.pushFailure(\n              'Exception while running qunit-bdd `' + hook + '` hook: ' +\n              (e.message || e),\n              QUnit.config.current.stack\n            );\n          }\n        }\n      });\n    });\n\n    if (parent) {\n      if (up) {\n        queue.push(function() { parent.prependHook(hook, up, env); });\n      } else {\n        queue.unshift(function() { parent.prependHook(hook, up, env); });\n      }\n    }\n\n    QUnit.config.queue.unshift.apply(QUnit.config.queue, queue);\n  };\n\n\n  /**\n   * Context state data. The root context handles top-level `before` and\n   * `after` callbacks.\n   */\n\n  var root = new Context();\n  var pendingContexts = [];\n  var contextStack = [root];\n\n  /**\n   * Gets the innermost context whose body is being evaluated.\n   *\n   * @private\n   * @return {?Context}\n   */\n  function currentContext() {\n    return contextStack[contextStack.length - 1];\n  }\n\n  /**\n   * Processes the current contexts by setting them up as QUnit modules.\n   *\n   * @private\n   */\n  function addTestsToQUnit() {\n    if (options.randomize) {\n      pendingContexts = randomize(pendingContexts);\n    }\n\n    pendingContexts.forEach(function(context) {\n      QUnit.module(context.fullDescription(), {\n        /**\n         * We use QUnit's current `queue` to ensure hook functions are run in\n         * the right order and obey QUnit's async rules. QUnit synchronizes\n         * calls in this order:\n         *\n         *   module('mod', {\n         *     setup: function(){},     // Step 1\n         *     teardown: function(){}   // Step 3\n         *  });\n         *\n         *  test('test', function(){}); // Step 2\n         *\n         * We add some abstractions to that, so we want to run things in this\n         * order:\n         *\n         *   describe('outer', function() {\n         *     lazy('a', function(){});        // Step 1\n         *\n         *     before(function(){});           // Step 3\n         *     before(function(){});           // Step 4\n         *\n         *     describe('inner', function() {\n         *       lazy('a', function(){});      // Step 2\n         *\n         *       before(function(){});         // Step 5\n         *       it('test', function(){});     // Step 6\n         *       after(function(){});          // Step 7\n         *     });\n         *\n         *     after(function(){});            // Step 8\n         *     after(function(){});            // Step 9\n         *   });\n         *\n         * So before `setup` is called below, the QUnit queue looks like this:\n         *\n         *   - setup\n         *   - test\n         *   - teardown\n         *\n         * QUnit unshifts `setup` and runs it. We then call `prependHook` which\n         * prepends our `before` callbacks so the queue now looks like this:\n         *\n         *   - before (#3)\n         *   - before (#4)\n         *   - before (#5)\n         *   - test\n         *   - teardown\n         *\n         * And then we call `prependHook` for the `lazySetup` callbacks, so we\n         * end up with this:\n         *\n         *   - lazySetup (#1)\n         *   - lazySetup (#2)\n         *   - before (#3)\n         *   - before (#4)\n         *   - before (#5)\n         *   - test\n         *   - teardown\n         *\n         * QUnit will ensure that each step is run only once\n         * `QUnit.config.semaphore` has gone back down to 0.\n         *\n         * Similarly, once `teardown` is run we add additional queue items for\n         * `lazyTeardown` and `after` callbacks.\n         */\n\n        setup: function() {\n          if (!QUnit.config.current.callback.skipped) {\n            context.prependHook('before', false, this);\n            context.prependHook('lazySetup', false, this);\n          }\n        },\n        teardown: function() {\n          if (!QUnit.config.current.callback.skipped) {\n            context.prependHook('lazyTeardown', true, this);\n            context.prependHook('after', true, this);\n          }\n        }\n      });\n\n      var tests = context.tests;\n\n      if (options.randomize) {\n        tests = randomize(tests.slice());\n      }\n\n      tests.forEach(function(test) {\n        QUnit.test(test.description, test.body);\n      });\n    });\n\n    pendingContexts.length = 0;\n  }\n\n  /**\n   * Shuffle the entries of `array` randomly.\n   *\n   * @private\n   * @param {Array.<T>} array\n   * @return {Array.<T>}\n   */\n  function shuffle(array) {\n    var j, x, i = array.length;\n    while (i) {\n       j = Math.floor(Math.random() * i);\n       x = array[--i];\n       array[i] = array[j];\n       array[j] = x;\n    }\n    return array;\n  }\n  var randomize = (typeof options.randomize === 'function') ?\n    options.randomize :\n    shuffle;\n\n  // Add test suites just before QUnit starts running.\n  QUnit.begin(addTestsToQUnit);\n\n  /**\n   * Creates a context and adds it to the current context state.\n   *\n   * @param {string} description\n   * @param {function(this: Context)} body\n   * @param {?object} options\n   */\n  function describe(description, body, options) {\n    var desc = new Context(description, currentContext(), options);\n\n    pendingContexts.push(desc);\n    contextStack.push(desc);\n    body.call(desc);\n    contextStack.pop();\n  }\n\n  /**\n   * Creates a test for the current context.\n   *\n   * @param {string} description\n   * @param {function()} body\n   * @param {boolean} skipped\n   */\n  function it(description, body, /* internal */ skipped) {\n    var context = currentContext();\n    if (context.skipped || skipped) {\n      description += ' (SKIPPED)';\n      body = skippedTestBody;\n    }\n    context.tests.push({\n      description: description,\n      body: body\n    });\n  }\n\n  /**\n   * All skipped tests do the same thing so we can reuse the body function,\n   * which is what this is for.\n   *\n   * @private\n   */\n  var skippedTestBody = function() {\n    QUnit.expect(0);\n\n    if (typeof document !== 'undefined') {\n      var testRow = document.getElementById(QUnit.config.current.id);\n      if (testRow && testRow.style) {\n        testRow.style.opacity = 0.5;\n      }\n    }\n  };\n  skippedTestBody.skipped = true;\n\n  /**\n   * Allows leaving a `describe` in place but having QUnit skip all the tests,\n   * as if you'd annotated all of them with `.skip` instead.\n   *\n   * @param {string} description\n   * @param {function()} body\n   */\n  describe.skip = function(description, body) {\n    describe(description, body, { skipped: true });\n  };\n\n  describe.only = function(description, body) {\n    var module = currentContext().fullDescription();\n    if (module) {\n      module += ' ' + description;\n    } else {\n      module = description;\n    }\n    QUnit.config.module = module;\n    describe(description, body);\n  };\n\n  /**\n   * Allows leaving a test intact but without it being run. It will be marked\n   * as skipped both in the name of the test and, if running with a DOM, by\n   * marking the test results.\n   *\n   * @param {string} description\n   * @param {function()} body\n   */\n  it.skip = function(description, body) {\n    it(description, body, true);\n  };\n\n  /**\n   * Allows running only a specific test by using `it.only` instead of `it`.\n   * This is the same as running with a specific module/filter combination, but\n   * is more practical in situations where accessing the QUnit UI or URL is\n   * difficult.\n   *\n   * @param {string} description\n   * @param {function()} body\n   */\n  it.only = function(description, body) {\n    QUnit.config.module = currentContext().fullDescription();\n    QUnit.config.filter = description;\n    it(description, body);\n  };\n\n  /**\n   * Registers a function to run before each test in the current context and\n   * all its descendant contexts.\n   *\n   * @param {function()} body\n   */\n  function before(body) {\n    currentContext().before.push(body);\n  }\n\n  /**\n   * Registers a function to run after each test in the current context and\n   * all its descendant contexts.\n   *\n   * @param {function()} body\n   */\n  function after(body) {\n    currentContext().after.push(body);\n  }\n\n  /**\n   * Registers a helper function on the current context.\n   *\n   * Example\n   *\n   *   describe('api', function() {\n   *     before(function() {\n   *       this.apiController = {};\n   *     });\n   *\n   *     helper('fireApiRequest', function() {\n   *       // full access to everything on `this` context.\n   *       // this.apiController.doSomething()...\n   *     });\n   *\n   *     it('works', function() {\n   *       this.fireApiRequest();\n   *     });\n   *\n   *     it('works another way', function() {\n   *       this.fireApiRequest();\n   *     });\n   *   });\n   *\n   * @param {function()} body\n   */\n  function helper(name, fn) {\n    lazy(name, function() { return fn; });\n  }\n\n  /**\n   * Registers a named value to be made available in all before/after/it blocks\n   * for the current context. This helper allows you to create complex values\n   * that are dependent on simpler values that may be overridden in child\n   * contexts.\n   *\n   * `value` may either be a function, in which case the value is lazily\n   * determined as needed, or a non-function value, in which case the given\n   * value will be used as-is. Dynamic values only have their value computed\n   * once per test. Keep in mind the value will not be generated at all if the\n   * value is not used.\n   *\n   * Example\n   *\n   *   describe('Person', function() {\n   *     lazy('person', function() {\n   *       return new Person(this.firstName, this.lastName);\n   *     });\n   *\n   *     describe('#name', function() {\n   *       context('with both first and last name', function() {\n   *         lazy('firstName, 'Jim');\n   *         lazy('lastName', 'Henson');\n   *\n   *         it('joins first and last names on spaces', function() {\n   *           expect(this.person.name).to.equal('Jim Henson');\n   *         });\n   *       });\n   *\n   *       context('with only first name', function() {\n   *         lazy('firstName, 'Jim');\n   *\n   *         it('uses only the first name', function() {\n   *           expect(this.person.name).to.equal('Jim');\n   *         });\n   *       });\n   *     });\n   *   });\n   *\n   * @param {string} name\n   * @param {*} value\n   */\n  function lazy(name, value) {\n    var cached = false;\n    var getter;\n\n    if (typeof value === 'function') {\n      getter = value;\n    } else {\n      getter = function() { return value; };\n    }\n\n    currentContext().lazySetup.push(function() {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        configurable: true,\n        get: function() {\n          if (!cached) {\n            value = getter.call(this);\n            cached = true;\n          }\n          return value;\n        },\n        set: function(newValue) {\n          cached = true;\n          value = newValue;\n        }\n      });\n    });\n\n    currentContext().lazyTeardown.push(function(context) {\n      cached = false;\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        configurable: true,\n        value: void 0\n      });\n    });\n  }\n\n  /**\n   * Represents an assertion created by calling `expect`.\n   *\n   * @class\n   * @private\n   * @param {*} actual\n   */\n  function Assertion(actual) {\n    this._actual = actual;\n    this._flags = {};\n  }\n\n  /**\n   * Creates a new Assertion.\n   *\n   * @param {*} actual\n   * @return {Assertion}\n   */\n  function expect(actual) {\n    var assertion = new Assertion(actual);\n\n    Object.defineProperty(assertion, '_previousExpectedAssertions', {\n      value: QUnit.config.current.expected,\n      enumerable: false\n    });\n\n    if (typeof actual === 'number') {\n      QUnit.config.current.expected = actual;\n    }\n\n    return assertion;\n  }\n\n  /**\n   * Add your own assertions or customize built-in ones here.\n   *\n   *   expect.configure({\n   *     // expect(2).to.be.even();\n   *     even: function() {\n   *       QUnit.ok(\n   *         !(this._actual % 2),\n   *         'expected ' + this._actual + ' to be even'\n   *       );\n   *     }\n   *   });\n   *\n   * @param {object} assertions\n   */\n  expect.configure = function(assertions) {\n    Object.getOwnPropertyNames(assertions).forEach(function(key) {\n      var descriptor = Object.getOwnPropertyDescriptor(assertions, key);\n      if (descriptor) {\n        descriptor.configurable = true;\n        if (descriptor.get) {\n          descriptor.get = assertionWrapper(key, descriptor.get);\n        } else if (typeof descriptor.value === 'function') {\n          descriptor.value = assertionWrapper(key, descriptor.value);\n        }\n        Object.defineProperty(Assertion.prototype, key, descriptor);\n      }\n    });\n  };\n\n  /**\n   * Creates a wrapper function that restores any expect count that might have\n   * been set before we overrode it.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   */\n  function assertionWrapper(key, fn) {\n    return function() {\n      var previousExpectedAssertions = this._previousExpectedAssertions;\n      QUnit.config.current.expected = previousExpectedAssertions;\n      return fn.apply(this, arguments);\n    };\n  }\n\n  expect.configure(Object.defineProperties({}, {\n    /**\n     * Negates the meaning of this assertion.\n     *\n     *   expect(1).not.to.equal(2);\n     *\n     * @return {Assertion}\n     */\n    not: {\n      get: function() {\n        this._flags.negate = !this._flags.negate;\n        return this;\n      }\n    },\n\n    /**\n     * Syntactic sugar to help readability:\n     *\n     *   // This doesn't read very nicely.\n     *   expect(1).equal(1);\n     *\n     *   // But this does.\n     *   expect(1).to.equal(1);\n     *\n     * @return {Assertion}\n     */\n    to: {\n      get: function() {\n        return this;\n      }\n    },\n\n    /**\n     * Syntactic sugar to help readability:\n     *\n     *   // This doesn't read very nicely.\n     *   expect(true).true();\n     *\n     *   // But this does.\n     *   expect(true).to.be.true();\n     *\n     * @return {Assertion}\n     */\n    be: {\n      get: function() {\n        return this;\n      }\n    },\n\n    /**\n     * Asserts that the actual and expected values are (or are not) equal. This\n     * method checks using strict equality (===) and delegates to\n     * QUnit.(not)strictEqual.\n     *\n     * @param {*} expected\n     * @param {?string} message\n     */\n    equal: {\n      value: function(expected, message) {\n        if (this._flags.negate) {\n          QUnit.notStrictEqual(this._actual, expected, message);\n        } else {\n          QUnit.strictEqual(this._actual, expected, message);\n        }\n      }\n    },\n\n    /**\n     * Asserts that the actual and expected values are (or are not) deeply equal.\n     * This method checks that object keys and values match up, recursively. This\n     * method delegates to QUnit.(not)deepEqual.\n     *\n     * @param {*} expected\n     * @param {?string} message\n     */\n    eql: {\n      value: function(expected, message) {\n        if (this._flags.negate) {\n          QUnit.notDeepEqual(this._actual, expected, message);\n        } else {\n          QUnit.deepEqual(this._actual, expected, message);\n        }\n      }\n    },\n\n    /**\n     * Asserts that the actual value is (or is not) undefined.\n     */\n    undefined: {\n      value: function(message) {\n        this.equal(void 0, message);\n      }\n    },\n\n    /**\n     * Asserts that the actual value is (or is not) null.\n     */\n    null: {\n      value: function(message) {\n        this.equal(null, message);\n      }\n    },\n\n    /**\n     * Asserts that the actual value is (or is not) false.\n     */\n    false: {\n      value: function(message) {\n        this.equal(false, message);\n      }\n    },\n\n    /**\n     * Asserts that the actual value is (or is not) true.\n     */\n    true: {\n      value: function(message) {\n        this.equal(true, message);\n      }\n    },\n\n    /**\n     * Asserts that the actual value is (or is not) null or undefined.\n     */\n    defined: {\n      value: function(message) {\n        if (this._flags.negate) {\n          QUnit.push(\n            this._actual === null || this._actual === undefined,\n            this._actual, undefined, message);\n        } else {\n          QUnit.push(\n            this._actual !== null && this._actual !== undefined,\n            this._actual, undefined, message);\n        }\n      }\n    }\n  }));\n\n  /**\n   * Fails a test unconditionally with the given message.\n   *\n   * @param {string} message\n   */\n  function fail(message) {\n    QUnit.ok(false, message);\n  }\n\n  /**\n   * GLOBALS configures which API methods should be globally exported, if any.\n   * In a CommonJS environment API methods will by default not be made global.\n   * In other environments they will be exported by default.\n   *\n   * To configure this behavior you can set QUNIT_BDD_OPTIONS.GLOBALS to true,\n   * false, or an object with function names as keys and boolean values. For\n   * example, to disable only the `lazy` function globally:\n   *\n   *   QUNIT_BDD_OPTIONS.GLOBALS = { lazy: false };\n   */\n  var GLOBALS = options.GLOBALS;\n  if (GLOBALS === undefined) {\n    GLOBALS = !exports;\n  }\n\n  function doExports(map) {\n    for (var key in map) {\n      if (map.hasOwnProperty(key)) {\n        if (exports) {\n          exports[key] = map[key];\n        }\n        if (GLOBALS === true ||\n            (typeof GLOBALS === 'object' &&\n             GLOBALS[key] !== false)) {\n          global[key] = map[key];\n        }\n      }\n    }\n  }\n\n  doExports({\n    describe: describe,\n    context: describe,\n    it: it,\n    before: before,\n    after: after,\n    lazy: lazy,\n    expect: expect,\n    fail: fail,\n    helper: helper\n  });\n}).call(this,\n  // global\n  (typeof global !== 'undefined') ? global :\n  (typeof window !== 'undefined') ? window : this,\n  // exports\n  (typeof module !== 'undefined' &&\n   typeof exports !== 'undefined' &&\n   module.exports === exports) ? exports : null,\n  // QUnit\n  (typeof QUnit !== 'undefined') && QUnit,\n  // options\n  (typeof QUNIT_BDD_OPTIONS !== 'undefined') &&\n   QUNIT_BDD_OPTIONS || this.QUNIT_BDD_OPTIONS || {}\n);\n","/**\n * Sinon.JS 1.10.3, 2014/07/11\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @author Contributors: https://github.com/cjohansen/Sinon.JS/blob/master/AUTHORS\n *\n * (The BSD License)\n * \n * Copyright (c) 2010-2014, Christian Johansen, christian@cjohansen.no\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n *     * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright notice,\n *       this list of conditions and the following disclaimer in the documentation\n *       and/or other materials provided with the distribution.\n *     * Neither the name of Christian Johansen nor the names of his contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nthis.sinon = (function () {\nvar samsam, formatio;\nfunction define(mod, deps, fn) { if (mod == \"samsam\") { samsam = deps(); } else if (typeof fn === \"function\") { formatio = fn(samsam); } }\ndefine.amd = {};\n((typeof define === \"function\" && define.amd && function (m) { define(\"samsam\", m); }) ||\n (typeof module === \"object\" &&\n      function (m) { module.exports = m(); }) || // Node\n function (m) { this.samsam = m(); } // Browser globals\n)(function () {\n    var o = Object.prototype;\n    var div = typeof document !== \"undefined\" && document.createElement(\"div\");\n\n    function isNaN(value) {\n        // Unlike global isNaN, this avoids type coercion\n        // typeof check avoids IE host object issues, hat tip to\n        // lodash\n        var val = value; // JsLint thinks value !== value is \"weird\"\n        return typeof value === \"number\" && value !== val;\n    }\n\n    function getClass(value) {\n        // Returns the internal [[Class]] by calling Object.prototype.toString\n        // with the provided value as this. Return value is a string, naming the\n        // internal class, e.g. \"Array\"\n        return o.toString.call(value).split(/[ \\]]/)[1];\n    }\n\n    /**\n     * @name samsam.isArguments\n     * @param Object object\n     *\n     * Returns ``true`` if ``object`` is an ``arguments`` object,\n     * ``false`` otherwise.\n     */\n    function isArguments(object) {\n        if (typeof object !== \"object\" || typeof object.length !== \"number\" ||\n                getClass(object) === \"Array\") {\n            return false;\n        }\n        if (typeof object.callee == \"function\") { return true; }\n        try {\n            object[object.length] = 6;\n            delete object[object.length];\n        } catch (e) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @name samsam.isElement\n     * @param Object object\n     *\n     * Returns ``true`` if ``object`` is a DOM element node. Unlike\n     * Underscore.js/lodash, this function will return ``false`` if ``object``\n     * is an *element-like* object, i.e. a regular object with a ``nodeType``\n     * property that holds the value ``1``.\n     */\n    function isElement(object) {\n        if (!object || object.nodeType !== 1 || !div) { return false; }\n        try {\n            object.appendChild(div);\n            object.removeChild(div);\n        } catch (e) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @name samsam.keys\n     * @param Object object\n     *\n     * Return an array of own property names.\n     */\n    function keys(object) {\n        var ks = [], prop;\n        for (prop in object) {\n            if (o.hasOwnProperty.call(object, prop)) { ks.push(prop); }\n        }\n        return ks;\n    }\n\n    /**\n     * @name samsam.isDate\n     * @param Object value\n     *\n     * Returns true if the object is a ``Date``, or *date-like*. Duck typing\n     * of date objects work by checking that the object has a ``getTime``\n     * function whose return value equals the return value from the object's\n     * ``valueOf``.\n     */\n    function isDate(value) {\n        return typeof value.getTime == \"function\" &&\n            value.getTime() == value.valueOf();\n    }\n\n    /**\n     * @name samsam.isNegZero\n     * @param Object value\n     *\n     * Returns ``true`` if ``value`` is ``-0``.\n     */\n    function isNegZero(value) {\n        return value === 0 && 1 / value === -Infinity;\n    }\n\n    /**\n     * @name samsam.equal\n     * @param Object obj1\n     * @param Object obj2\n     *\n     * Returns ``true`` if two objects are strictly equal. Compared to\n     * ``===`` there are two exceptions:\n     *\n     *   - NaN is considered equal to NaN\n     *   - -0 and +0 are not considered equal\n     */\n    function identical(obj1, obj2) {\n        if (obj1 === obj2 || (isNaN(obj1) && isNaN(obj2))) {\n            return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2);\n        }\n    }\n\n\n    /**\n     * @name samsam.deepEqual\n     * @param Object obj1\n     * @param Object obj2\n     *\n     * Deep equal comparison. Two values are \"deep equal\" if:\n     *\n     *   - They are equal, according to samsam.identical\n     *   - They are both date objects representing the same time\n     *   - They are both arrays containing elements that are all deepEqual\n     *   - They are objects with the same set of properties, and each property\n     *     in ``obj1`` is deepEqual to the corresponding property in ``obj2``\n     *\n     * Supports cyclic objects.\n     */\n    function deepEqualCyclic(obj1, obj2) {\n\n        // used for cyclic comparison\n        // contain already visited objects\n        var objects1 = [],\n            objects2 = [],\n        // contain pathes (position in the object structure)\n        // of the already visited objects\n        // indexes same as in objects arrays\n            paths1 = [],\n            paths2 = [],\n        // contains combinations of already compared objects\n        // in the manner: { \"$1['ref']$2['ref']\": true }\n            compared = {};\n\n        /**\n         * used to check, if the value of a property is an object\n         * (cyclic logic is only needed for objects)\n         * only needed for cyclic logic\n         */\n        function isObject(value) {\n\n            if (typeof value === 'object' && value !== null &&\n                    !(value instanceof Boolean) &&\n                    !(value instanceof Date)    &&\n                    !(value instanceof Number)  &&\n                    !(value instanceof RegExp)  &&\n                    !(value instanceof String)) {\n\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * returns the index of the given object in the\n         * given objects array, -1 if not contained\n         * only needed for cyclic logic\n         */\n        function getIndex(objects, obj) {\n\n            var i;\n            for (i = 0; i < objects.length; i++) {\n                if (objects[i] === obj) {\n                    return i;\n                }\n            }\n\n            return -1;\n        }\n\n        // does the recursion for the deep equal check\n        return (function deepEqual(obj1, obj2, path1, path2) {\n            var type1 = typeof obj1;\n            var type2 = typeof obj2;\n\n            // == null also matches undefined\n            if (obj1 === obj2 ||\n                    isNaN(obj1) || isNaN(obj2) ||\n                    obj1 == null || obj2 == null ||\n                    type1 !== \"object\" || type2 !== \"object\") {\n\n                return identical(obj1, obj2);\n            }\n\n            // Elements are only equal if identical(expected, actual)\n            if (isElement(obj1) || isElement(obj2)) { return false; }\n\n            var isDate1 = isDate(obj1), isDate2 = isDate(obj2);\n            if (isDate1 || isDate2) {\n                if (!isDate1 || !isDate2 || obj1.getTime() !== obj2.getTime()) {\n                    return false;\n                }\n            }\n\n            if (obj1 instanceof RegExp && obj2 instanceof RegExp) {\n                if (obj1.toString() !== obj2.toString()) { return false; }\n            }\n\n            var class1 = getClass(obj1);\n            var class2 = getClass(obj2);\n            var keys1 = keys(obj1);\n            var keys2 = keys(obj2);\n\n            if (isArguments(obj1) || isArguments(obj2)) {\n                if (obj1.length !== obj2.length) { return false; }\n            } else {\n                if (type1 !== type2 || class1 !== class2 ||\n                        keys1.length !== keys2.length) {\n                    return false;\n                }\n            }\n\n            var key, i, l,\n                // following vars are used for the cyclic logic\n                value1, value2,\n                isObject1, isObject2,\n                index1, index2,\n                newPath1, newPath2;\n\n            for (i = 0, l = keys1.length; i < l; i++) {\n                key = keys1[i];\n                if (!o.hasOwnProperty.call(obj2, key)) {\n                    return false;\n                }\n\n                // Start of the cyclic logic\n\n                value1 = obj1[key];\n                value2 = obj2[key];\n\n                isObject1 = isObject(value1);\n                isObject2 = isObject(value2);\n\n                // determine, if the objects were already visited\n                // (it's faster to check for isObject first, than to\n                // get -1 from getIndex for non objects)\n                index1 = isObject1 ? getIndex(objects1, value1) : -1;\n                index2 = isObject2 ? getIndex(objects2, value2) : -1;\n\n                // determine the new pathes of the objects\n                // - for non cyclic objects the current path will be extended\n                //   by current property name\n                // - for cyclic objects the stored path is taken\n                newPath1 = index1 !== -1\n                    ? paths1[index1]\n                    : path1 + '[' + JSON.stringify(key) + ']';\n                newPath2 = index2 !== -1\n                    ? paths2[index2]\n                    : path2 + '[' + JSON.stringify(key) + ']';\n\n                // stop recursion if current objects are already compared\n                if (compared[newPath1 + newPath2]) {\n                    return true;\n                }\n\n                // remember the current objects and their pathes\n                if (index1 === -1 && isObject1) {\n                    objects1.push(value1);\n                    paths1.push(newPath1);\n                }\n                if (index2 === -1 && isObject2) {\n                    objects2.push(value2);\n                    paths2.push(newPath2);\n                }\n\n                // remember that the current objects are already compared\n                if (isObject1 && isObject2) {\n                    compared[newPath1 + newPath2] = true;\n                }\n\n                // End of cyclic logic\n\n                // neither value1 nor value2 is a cycle\n                // continue with next level\n                if (!deepEqual(value1, value2, newPath1, newPath2)) {\n                    return false;\n                }\n            }\n\n            return true;\n\n        }(obj1, obj2, '$1', '$2'));\n    }\n\n    var match;\n\n    function arrayContains(array, subset) {\n        if (subset.length === 0) { return true; }\n        var i, l, j, k;\n        for (i = 0, l = array.length; i < l; ++i) {\n            if (match(array[i], subset[0])) {\n                for (j = 0, k = subset.length; j < k; ++j) {\n                    if (!match(array[i + j], subset[j])) { return false; }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @name samsam.match\n     * @param Object object\n     * @param Object matcher\n     *\n     * Compare arbitrary value ``object`` with matcher.\n     */\n    match = function match(object, matcher) {\n        if (matcher && typeof matcher.test === \"function\") {\n            return matcher.test(object);\n        }\n\n        if (typeof matcher === \"function\") {\n            return matcher(object) === true;\n        }\n\n        if (typeof matcher === \"string\") {\n            matcher = matcher.toLowerCase();\n            var notNull = typeof object === \"string\" || !!object;\n            return notNull &&\n                (String(object)).toLowerCase().indexOf(matcher) >= 0;\n        }\n\n        if (typeof matcher === \"number\") {\n            return matcher === object;\n        }\n\n        if (typeof matcher === \"boolean\") {\n            return matcher === object;\n        }\n\n        if (getClass(object) === \"Array\" && getClass(matcher) === \"Array\") {\n            return arrayContains(object, matcher);\n        }\n\n        if (matcher && typeof matcher === \"object\") {\n            var prop;\n            for (prop in matcher) {\n                if (!match(object[prop], matcher[prop])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        throw new Error(\"Matcher was not a string, a number, a \" +\n                        \"function, a boolean or an object\");\n    };\n\n    return {\n        isArguments: isArguments,\n        isElement: isElement,\n        isDate: isDate,\n        isNegZero: isNegZero,\n        identical: identical,\n        deepEqual: deepEqualCyclic,\n        match: match,\n        keys: keys\n    };\n});\n((typeof define === \"function\" && define.amd && function (m) {\n    define(\"formatio\", [\"samsam\"], m);\n}) || (typeof module === \"object\" && function (m) {\n    module.exports = m(require(\"samsam\"));\n}) || function (m) { this.formatio = m(this.samsam); }\n)(function (samsam) {\n    \n    var formatio = {\n        excludeConstructors: [\"Object\", /^.$/],\n        quoteStrings: true\n    };\n\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    var specialObjects = [];\n    if (typeof global !== \"undefined\") {\n        specialObjects.push({ object: global, value: \"[object global]\" });\n    }\n    if (typeof document !== \"undefined\") {\n        specialObjects.push({\n            object: document,\n            value: \"[object HTMLDocument]\"\n        });\n    }\n    if (typeof window !== \"undefined\") {\n        specialObjects.push({ object: window, value: \"[object Window]\" });\n    }\n\n    function functionName(func) {\n        if (!func) { return \"\"; }\n        if (func.displayName) { return func.displayName; }\n        if (func.name) { return func.name; }\n        var matches = func.toString().match(/function\\s+([^\\(]+)/m);\n        return (matches && matches[1]) || \"\";\n    }\n\n    function constructorName(f, object) {\n        var name = functionName(object && object.constructor);\n        var excludes = f.excludeConstructors ||\n                formatio.excludeConstructors || [];\n\n        var i, l;\n        for (i = 0, l = excludes.length; i < l; ++i) {\n            if (typeof excludes[i] === \"string\" && excludes[i] === name) {\n                return \"\";\n            } else if (excludes[i].test && excludes[i].test(name)) {\n                return \"\";\n            }\n        }\n\n        return name;\n    }\n\n    function isCircular(object, objects) {\n        if (typeof object !== \"object\") { return false; }\n        var i, l;\n        for (i = 0, l = objects.length; i < l; ++i) {\n            if (objects[i] === object) { return true; }\n        }\n        return false;\n    }\n\n    function ascii(f, object, processed, indent) {\n        if (typeof object === \"string\") {\n            var qs = f.quoteStrings;\n            var quote = typeof qs !== \"boolean\" || qs;\n            return processed || quote ? '\"' + object + '\"' : object;\n        }\n\n        if (typeof object === \"function\" && !(object instanceof RegExp)) {\n            return ascii.func(object);\n        }\n\n        processed = processed || [];\n\n        if (isCircular(object, processed)) { return \"[Circular]\"; }\n\n        if (Object.prototype.toString.call(object) === \"[object Array]\") {\n            return ascii.array.call(f, object, processed);\n        }\n\n        if (!object) { return String((1/object) === -Infinity ? \"-0\" : object); }\n        if (samsam.isElement(object)) { return ascii.element(object); }\n\n        if (typeof object.toString === \"function\" &&\n                object.toString !== Object.prototype.toString) {\n            return object.toString();\n        }\n\n        var i, l;\n        for (i = 0, l = specialObjects.length; i < l; i++) {\n            if (object === specialObjects[i].object) {\n                return specialObjects[i].value;\n            }\n        }\n\n        return ascii.object.call(f, object, processed, indent);\n    }\n\n    ascii.func = function (func) {\n        return \"function \" + functionName(func) + \"() {}\";\n    };\n\n    ascii.array = function (array, processed) {\n        processed = processed || [];\n        processed.push(array);\n        var i, l, pieces = [];\n        for (i = 0, l = array.length; i < l; ++i) {\n            pieces.push(ascii(this, array[i], processed));\n        }\n        return \"[\" + pieces.join(\", \") + \"]\";\n    };\n\n    ascii.object = function (object, processed, indent) {\n        processed = processed || [];\n        processed.push(object);\n        indent = indent || 0;\n        var pieces = [], properties = samsam.keys(object).sort();\n        var length = 3;\n        var prop, str, obj, i, l;\n\n        for (i = 0, l = properties.length; i < l; ++i) {\n            prop = properties[i];\n            obj = object[prop];\n\n            if (isCircular(obj, processed)) {\n                str = \"[Circular]\";\n            } else {\n                str = ascii(this, obj, processed, indent + 2);\n            }\n\n            str = (/\\s/.test(prop) ? '\"' + prop + '\"' : prop) + \": \" + str;\n            length += str.length;\n            pieces.push(str);\n        }\n\n        var cons = constructorName(this, object);\n        var prefix = cons ? \"[\" + cons + \"] \" : \"\";\n        var is = \"\";\n        for (i = 0, l = indent; i < l; ++i) { is += \" \"; }\n\n        if (length + indent > 80) {\n            return prefix + \"{\\n  \" + is + pieces.join(\",\\n  \" + is) + \"\\n\" +\n                is + \"}\";\n        }\n        return prefix + \"{ \" + pieces.join(\", \") + \" }\";\n    };\n\n    ascii.element = function (element) {\n        var tagName = element.tagName.toLowerCase();\n        var attrs = element.attributes, attr, pairs = [], attrName, i, l, val;\n\n        for (i = 0, l = attrs.length; i < l; ++i) {\n            attr = attrs.item(i);\n            attrName = attr.nodeName.toLowerCase().replace(\"html:\", \"\");\n            val = attr.nodeValue;\n            if (attrName !== \"contenteditable\" || val !== \"inherit\") {\n                if (!!val) { pairs.push(attrName + \"=\\\"\" + val + \"\\\"\"); }\n            }\n        }\n\n        var formatted = \"<\" + tagName + (pairs.length > 0 ? \" \" : \"\");\n        var content = element.innerHTML;\n\n        if (content.length > 20) {\n            content = content.substr(0, 20) + \"[...]\";\n        }\n\n        var res = formatted + pairs.join(\" \") + \">\" + content +\n                \"</\" + tagName + \">\";\n\n        return res.replace(/ contentEditable=\"inherit\"/, \"\");\n    };\n\n    function Formatio(options) {\n        for (var opt in options) {\n            this[opt] = options[opt];\n        }\n    }\n\n    Formatio.prototype = {\n        functionName: functionName,\n\n        configure: function (options) {\n            return new Formatio(options);\n        },\n\n        constructorName: function (object) {\n            return constructorName(this, object);\n        },\n\n        ascii: function (object, processed, indent) {\n            return ascii(this, object, processed, indent);\n        }\n    };\n\n    return Formatio.prototype;\n});\n/*jslint eqeqeq: false, onevar: false, forin: true, nomen: false, regexp: false, plusplus: false*/\n/*global module, require, __dirname, document*/\n/**\n * Sinon core utilities. For internal use only.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\nvar sinon = (function (formatio) {\n    var div = typeof document != \"undefined\" && document.createElement(\"div\");\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    function isDOMNode(obj) {\n        var success = false;\n\n        try {\n            obj.appendChild(div);\n            success = div.parentNode == obj;\n        } catch (e) {\n            return false;\n        } finally {\n            try {\n                obj.removeChild(div);\n            } catch (e) {\n                // Remove failed, not much we can do about that\n            }\n        }\n\n        return success;\n    }\n\n    function isElement(obj) {\n        return div && obj && obj.nodeType === 1 && isDOMNode(obj);\n    }\n\n    function isFunction(obj) {\n        return typeof obj === \"function\" || !!(obj && obj.constructor && obj.call && obj.apply);\n    }\n\n    function isReallyNaN(val) {\n        return typeof val === 'number' && isNaN(val);\n    }\n\n    function mirrorProperties(target, source) {\n        for (var prop in source) {\n            if (!hasOwn.call(target, prop)) {\n                target[prop] = source[prop];\n            }\n        }\n    }\n\n    function isRestorable (obj) {\n        return typeof obj === \"function\" && typeof obj.restore === \"function\" && obj.restore.sinon;\n    }\n\n    var sinon = {\n        wrapMethod: function wrapMethod(object, property, method) {\n            if (!object) {\n                throw new TypeError(\"Should wrap property of object\");\n            }\n\n            if (typeof method != \"function\") {\n                throw new TypeError(\"Method wrapper should be function\");\n            }\n\n            var wrappedMethod = object[property],\n                error;\n\n            if (!isFunction(wrappedMethod)) {\n                error = new TypeError(\"Attempted to wrap \" + (typeof wrappedMethod) + \" property \" +\n                                    property + \" as function\");\n            } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\n                error = new TypeError(\"Attempted to wrap \" + property + \" which is already wrapped\");\n            } else if (wrappedMethod.calledBefore) {\n                var verb = !!wrappedMethod.returns ? \"stubbed\" : \"spied on\";\n                error = new TypeError(\"Attempted to wrap \" + property + \" which is already \" + verb);\n            }\n\n            if (error) {\n                if (wrappedMethod && wrappedMethod._stack) {\n                    error.stack += '\\n--------------\\n' + wrappedMethod._stack;\n                }\n                throw error;\n            }\n\n            // IE 8 does not support hasOwnProperty on the window object and Firefox has a problem\n            // when using hasOwn.call on objects from other frames.\n            var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);\n            object[property] = method;\n            method.displayName = property;\n            // Set up a stack trace which can be used later to find what line of\n            // code the original method was created on.\n            method._stack = (new Error('Stack Trace for original')).stack;\n\n            method.restore = function () {\n                // For prototype properties try to reset by delete first.\n                // If this fails (ex: localStorage on mobile safari) then force a reset\n                // via direct assignment.\n                if (!owned) {\n                    delete object[property];\n                }\n                if (object[property] === method) {\n                    object[property] = wrappedMethod;\n                }\n            };\n\n            method.restore.sinon = true;\n            mirrorProperties(method, wrappedMethod);\n\n            return method;\n        },\n\n        extend: function extend(target) {\n            for (var i = 1, l = arguments.length; i < l; i += 1) {\n                for (var prop in arguments[i]) {\n                    if (arguments[i].hasOwnProperty(prop)) {\n                        target[prop] = arguments[i][prop];\n                    }\n\n                    // DONT ENUM bug, only care about toString\n                    if (arguments[i].hasOwnProperty(\"toString\") &&\n                        arguments[i].toString != target.toString) {\n                        target.toString = arguments[i].toString;\n                    }\n                }\n            }\n\n            return target;\n        },\n\n        create: function create(proto) {\n            var F = function () {};\n            F.prototype = proto;\n            return new F();\n        },\n\n        deepEqual: function deepEqual(a, b) {\n            if (sinon.match && sinon.match.isMatcher(a)) {\n                return a.test(b);\n            }\n\n            if (typeof a != 'object' || typeof b != 'object') {\n                if (isReallyNaN(a) && isReallyNaN(b)) {\n                    return true;\n                } else {\n                    return a === b;\n                }\n            }\n\n            if (isElement(a) || isElement(b)) {\n                return a === b;\n            }\n\n            if (a === b) {\n                return true;\n            }\n\n            if ((a === null && b !== null) || (a !== null && b === null)) {\n                return false;\n            }\n\n            if (a instanceof RegExp && b instanceof RegExp) {\n              return (a.source === b.source) && (a.global === b.global) &&\n                (a.ignoreCase === b.ignoreCase) && (a.multiline === b.multiline);\n            }\n\n            var aString = Object.prototype.toString.call(a);\n            if (aString != Object.prototype.toString.call(b)) {\n                return false;\n            }\n\n            if (aString == \"[object Date]\") {\n                return a.valueOf() === b.valueOf();\n            }\n\n            var prop, aLength = 0, bLength = 0;\n\n            if (aString == \"[object Array]\" && a.length !== b.length) {\n                return false;\n            }\n\n            for (prop in a) {\n                aLength += 1;\n\n                if (!(prop in b)) {\n                    return false;\n                }\n\n                if (!deepEqual(a[prop], b[prop])) {\n                    return false;\n                }\n            }\n\n            for (prop in b) {\n                bLength += 1;\n            }\n\n            return aLength == bLength;\n        },\n\n        functionName: function functionName(func) {\n            var name = func.displayName || func.name;\n\n            // Use function decomposition as a last resort to get function\n            // name. Does not rely on function decomposition to work - if it\n            // doesn't debugging will be slightly less informative\n            // (i.e. toString will say 'spy' rather than 'myFunc').\n            if (!name) {\n                var matches = func.toString().match(/function ([^\\s\\(]+)/);\n                name = matches && matches[1];\n            }\n\n            return name;\n        },\n\n        functionToString: function toString() {\n            if (this.getCall && this.callCount) {\n                var thisValue, prop, i = this.callCount;\n\n                while (i--) {\n                    thisValue = this.getCall(i).thisValue;\n\n                    for (prop in thisValue) {\n                        if (thisValue[prop] === this) {\n                            return prop;\n                        }\n                    }\n                }\n            }\n\n            return this.displayName || \"sinon fake\";\n        },\n\n        getConfig: function (custom) {\n            var config = {};\n            custom = custom || {};\n            var defaults = sinon.defaultConfig;\n\n            for (var prop in defaults) {\n                if (defaults.hasOwnProperty(prop)) {\n                    config[prop] = custom.hasOwnProperty(prop) ? custom[prop] : defaults[prop];\n                }\n            }\n\n            return config;\n        },\n\n        format: function (val) {\n            return \"\" + val;\n        },\n\n        defaultConfig: {\n            injectIntoThis: true,\n            injectInto: null,\n            properties: [\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"],\n            useFakeTimers: true,\n            useFakeServer: true\n        },\n\n        timesInWords: function timesInWords(count) {\n            return count == 1 && \"once\" ||\n                count == 2 && \"twice\" ||\n                count == 3 && \"thrice\" ||\n                (count || 0) + \" times\";\n        },\n\n        calledInOrder: function (spies) {\n            for (var i = 1, l = spies.length; i < l; i++) {\n                if (!spies[i - 1].calledBefore(spies[i]) || !spies[i].called) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n\n        orderByFirstCall: function (spies) {\n            return spies.sort(function (a, b) {\n                // uuid, won't ever be equal\n                var aCall = a.getCall(0);\n                var bCall = b.getCall(0);\n                var aId = aCall && aCall.callId || -1;\n                var bId = bCall && bCall.callId || -1;\n\n                return aId < bId ? -1 : 1;\n            });\n        },\n\n        log: function () {},\n\n        logError: function (label, err) {\n            var msg = label + \" threw exception: \";\n            sinon.log(msg + \"[\" + err.name + \"] \" + err.message);\n            if (err.stack) { sinon.log(err.stack); }\n\n            setTimeout(function () {\n                err.message = msg + err.message;\n                throw err;\n            }, 0);\n        },\n\n        typeOf: function (value) {\n            if (value === null) {\n                return \"null\";\n            }\n            else if (value === undefined) {\n                return \"undefined\";\n            }\n            var string = Object.prototype.toString.call(value);\n            return string.substring(8, string.length - 1).toLowerCase();\n        },\n\n        createStubInstance: function (constructor) {\n            if (typeof constructor !== \"function\") {\n                throw new TypeError(\"The constructor should be a function.\");\n            }\n            return sinon.stub(sinon.create(constructor.prototype));\n        },\n\n        restore: function (object) {\n            if (object !== null && typeof object === \"object\") {\n                for (var prop in object) {\n                    if (isRestorable(object[prop])) {\n                        object[prop].restore();\n                    }\n                }\n            }\n            else if (isRestorable(object)) {\n                object.restore();\n            }\n        }\n    };\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require == \"function\";\n    var isAMD = typeof define === 'function' && typeof define.amd === 'object' && define.amd;\n\n    function makePublicAPI(require, exports, module) {\n        module.exports = sinon;\n        sinon.spy = require(\"./sinon/spy\");\n        sinon.spyCall = require(\"./sinon/call\");\n        sinon.behavior = require(\"./sinon/behavior\");\n        sinon.stub = require(\"./sinon/stub\");\n        sinon.mock = require(\"./sinon/mock\");\n        sinon.collection = require(\"./sinon/collection\");\n        sinon.assert = require(\"./sinon/assert\");\n        sinon.sandbox = require(\"./sinon/sandbox\");\n        sinon.test = require(\"./sinon/test\");\n        sinon.testCase = require(\"./sinon/test_case\");\n        sinon.match = require(\"./sinon/match\");\n    }\n\n    if (isAMD) {\n        define(makePublicAPI);\n    } else if (isNode) {\n        try {\n            formatio = require(\"formatio\");\n        } catch (e) {}\n        makePublicAPI(require, exports, module);\n    }\n\n    if (formatio) {\n        var formatter = formatio.configure({ quoteStrings: false });\n        sinon.format = function () {\n            return formatter.ascii.apply(formatter, arguments);\n        };\n    } else if (isNode) {\n        try {\n            var util = require(\"util\");\n            sinon.format = function (value) {\n                return typeof value == \"object\" && value.toString === Object.prototype.toString ? util.inspect(value) : value;\n            };\n        } catch (e) {\n            /* Node, but no util module - would be very old, but better safe than\n             sorry */\n        }\n    }\n\n    return sinon;\n}(typeof formatio == \"object\" && formatio));\n\n/* @depend ../sinon.js */\n/*jslint eqeqeq: false, onevar: false, plusplus: false*/\n/*global module, require, sinon*/\n/**\n * Match functions\n *\n * @author Maximilian Antoni (mail@maxantoni.de)\n * @license BSD\n *\n * Copyright (c) 2012 Maximilian Antoni\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module !== \"undefined\" && module.exports && typeof require == \"function\";\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function assertType(value, type, name) {\n        var actual = sinon.typeOf(value);\n        if (actual !== type) {\n            throw new TypeError(\"Expected type of \" + name + \" to be \" +\n                type + \", but was \" + actual);\n        }\n    }\n\n    var matcher = {\n        toString: function () {\n            return this.message;\n        }\n    };\n\n    function isMatcher(object) {\n        return matcher.isPrototypeOf(object);\n    }\n\n    function matchObject(expectation, actual) {\n        if (actual === null || actual === undefined) {\n            return false;\n        }\n        for (var key in expectation) {\n            if (expectation.hasOwnProperty(key)) {\n                var exp = expectation[key];\n                var act = actual[key];\n                if (match.isMatcher(exp)) {\n                    if (!exp.test(act)) {\n                        return false;\n                    }\n                } else if (sinon.typeOf(exp) === \"object\") {\n                    if (!matchObject(exp, act)) {\n                        return false;\n                    }\n                } else if (!sinon.deepEqual(exp, act)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    matcher.or = function (m2) {\n        if (!arguments.length) {\n            throw new TypeError(\"Matcher expected\");\n        } else if (!isMatcher(m2)) {\n            m2 = match(m2);\n        }\n        var m1 = this;\n        var or = sinon.create(matcher);\n        or.test = function (actual) {\n            return m1.test(actual) || m2.test(actual);\n        };\n        or.message = m1.message + \".or(\" + m2.message + \")\";\n        return or;\n    };\n\n    matcher.and = function (m2) {\n        if (!arguments.length) {\n            throw new TypeError(\"Matcher expected\");\n        } else if (!isMatcher(m2)) {\n            m2 = match(m2);\n        }\n        var m1 = this;\n        var and = sinon.create(matcher);\n        and.test = function (actual) {\n            return m1.test(actual) && m2.test(actual);\n        };\n        and.message = m1.message + \".and(\" + m2.message + \")\";\n        return and;\n    };\n\n    var match = function (expectation, message) {\n        var m = sinon.create(matcher);\n        var type = sinon.typeOf(expectation);\n        switch (type) {\n        case \"object\":\n            if (typeof expectation.test === \"function\") {\n                m.test = function (actual) {\n                    return expectation.test(actual) === true;\n                };\n                m.message = \"match(\" + sinon.functionName(expectation.test) + \")\";\n                return m;\n            }\n            var str = [];\n            for (var key in expectation) {\n                if (expectation.hasOwnProperty(key)) {\n                    str.push(key + \": \" + expectation[key]);\n                }\n            }\n            m.test = function (actual) {\n                return matchObject(expectation, actual);\n            };\n            m.message = \"match(\" + str.join(\", \") + \")\";\n            break;\n        case \"number\":\n            m.test = function (actual) {\n                return expectation == actual;\n            };\n            break;\n        case \"string\":\n            m.test = function (actual) {\n                if (typeof actual !== \"string\") {\n                    return false;\n                }\n                return actual.indexOf(expectation) !== -1;\n            };\n            m.message = \"match(\\\"\" + expectation + \"\\\")\";\n            break;\n        case \"regexp\":\n            m.test = function (actual) {\n                if (typeof actual !== \"string\") {\n                    return false;\n                }\n                return expectation.test(actual);\n            };\n            break;\n        case \"function\":\n            m.test = expectation;\n            if (message) {\n                m.message = message;\n            } else {\n                m.message = \"match(\" + sinon.functionName(expectation) + \")\";\n            }\n            break;\n        default:\n            m.test = function (actual) {\n              return sinon.deepEqual(expectation, actual);\n            };\n        }\n        if (!m.message) {\n            m.message = \"match(\" + expectation + \")\";\n        }\n        return m;\n    };\n\n    match.isMatcher = isMatcher;\n\n    match.any = match(function () {\n        return true;\n    }, \"any\");\n\n    match.defined = match(function (actual) {\n        return actual !== null && actual !== undefined;\n    }, \"defined\");\n\n    match.truthy = match(function (actual) {\n        return !!actual;\n    }, \"truthy\");\n\n    match.falsy = match(function (actual) {\n        return !actual;\n    }, \"falsy\");\n\n    match.same = function (expectation) {\n        return match(function (actual) {\n            return expectation === actual;\n        }, \"same(\" + expectation + \")\");\n    };\n\n    match.typeOf = function (type) {\n        assertType(type, \"string\", \"type\");\n        return match(function (actual) {\n            return sinon.typeOf(actual) === type;\n        }, \"typeOf(\\\"\" + type + \"\\\")\");\n    };\n\n    match.instanceOf = function (type) {\n        assertType(type, \"function\", \"type\");\n        return match(function (actual) {\n            return actual instanceof type;\n        }, \"instanceOf(\" + sinon.functionName(type) + \")\");\n    };\n\n    function createPropertyMatcher(propertyTest, messagePrefix) {\n        return function (property, value) {\n            assertType(property, \"string\", \"property\");\n            var onlyProperty = arguments.length === 1;\n            var message = messagePrefix + \"(\\\"\" + property + \"\\\"\";\n            if (!onlyProperty) {\n                message += \", \" + value;\n            }\n            message += \")\";\n            return match(function (actual) {\n                if (actual === undefined || actual === null ||\n                        !propertyTest(actual, property)) {\n                    return false;\n                }\n                return onlyProperty || sinon.deepEqual(value, actual[property]);\n            }, message);\n        };\n    }\n\n    match.has = createPropertyMatcher(function (actual, property) {\n        if (typeof actual === \"object\") {\n            return property in actual;\n        }\n        return actual[property] !== undefined;\n    }, \"has\");\n\n    match.hasOwn = createPropertyMatcher(function (actual, property) {\n        return actual.hasOwnProperty(property);\n    }, \"hasOwn\");\n\n    match.bool = match.typeOf(\"boolean\");\n    match.number = match.typeOf(\"number\");\n    match.string = match.typeOf(\"string\");\n    match.object = match.typeOf(\"object\");\n    match.func = match.typeOf(\"function\");\n    match.array = match.typeOf(\"array\");\n    match.regexp = match.typeOf(\"regexp\");\n    match.date = match.typeOf(\"date\");\n\n    sinon.match = match;\n\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], function(module) { module.exports = match; });\n    } else if (commonJSModule) {\n        module.exports = match;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n  * @depend ../sinon.js\n  * @depend match.js\n  */\n/*jslint eqeqeq: false, onevar: false, plusplus: false*/\n/*global module, require, sinon*/\n/**\n  * Spy calls\n  *\n  * @author Christian Johansen (christian@cjohansen.no)\n  * @author Maximilian Antoni (mail@maxantoni.de)\n  * @license BSD\n  *\n  * Copyright (c) 2010-2013 Christian Johansen\n  * Copyright (c) 2013 Maximilian Antoni\n  */\n\n(function (sinon) {\n    var commonJSModule = typeof module !== \"undefined\" && module.exports && typeof require == \"function\";\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function throwYieldError(proxy, text, args) {\n        var msg = sinon.functionName(proxy) + text;\n        if (args.length) {\n            msg += \" Received [\" + slice.call(args).join(\", \") + \"]\";\n        }\n        throw new Error(msg);\n    }\n\n    var slice = Array.prototype.slice;\n\n    var callProto = {\n        calledOn: function calledOn(thisValue) {\n            if (sinon.match && sinon.match.isMatcher(thisValue)) {\n                return thisValue.test(this.thisValue);\n            }\n            return this.thisValue === thisValue;\n        },\n\n        calledWith: function calledWith() {\n            for (var i = 0, l = arguments.length; i < l; i += 1) {\n                if (!sinon.deepEqual(arguments[i], this.args[i])) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n\n        calledWithMatch: function calledWithMatch() {\n            for (var i = 0, l = arguments.length; i < l; i += 1) {\n                var actual = this.args[i];\n                var expectation = arguments[i];\n                if (!sinon.match || !sinon.match(expectation).test(actual)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        calledWithExactly: function calledWithExactly() {\n            return arguments.length == this.args.length &&\n                this.calledWith.apply(this, arguments);\n        },\n\n        notCalledWith: function notCalledWith() {\n            return !this.calledWith.apply(this, arguments);\n        },\n\n        notCalledWithMatch: function notCalledWithMatch() {\n            return !this.calledWithMatch.apply(this, arguments);\n        },\n\n        returned: function returned(value) {\n            return sinon.deepEqual(value, this.returnValue);\n        },\n\n        threw: function threw(error) {\n            if (typeof error === \"undefined\" || !this.exception) {\n                return !!this.exception;\n            }\n\n            return this.exception === error || this.exception.name === error;\n        },\n\n        calledWithNew: function calledWithNew() {\n            return this.proxy.prototype && this.thisValue instanceof this.proxy;\n        },\n\n        calledBefore: function (other) {\n            return this.callId < other.callId;\n        },\n\n        calledAfter: function (other) {\n            return this.callId > other.callId;\n        },\n\n        callArg: function (pos) {\n            this.args[pos]();\n        },\n\n        callArgOn: function (pos, thisValue) {\n            this.args[pos].apply(thisValue);\n        },\n\n        callArgWith: function (pos) {\n            this.callArgOnWith.apply(this, [pos, null].concat(slice.call(arguments, 1)));\n        },\n\n        callArgOnWith: function (pos, thisValue) {\n            var args = slice.call(arguments, 2);\n            this.args[pos].apply(thisValue, args);\n        },\n\n        \"yield\": function () {\n            this.yieldOn.apply(this, [null].concat(slice.call(arguments, 0)));\n        },\n\n        yieldOn: function (thisValue) {\n            var args = this.args;\n            for (var i = 0, l = args.length; i < l; ++i) {\n                if (typeof args[i] === \"function\") {\n                    args[i].apply(thisValue, slice.call(arguments, 1));\n                    return;\n                }\n            }\n            throwYieldError(this.proxy, \" cannot yield since no callback was passed.\", args);\n        },\n\n        yieldTo: function (prop) {\n            this.yieldToOn.apply(this, [prop, null].concat(slice.call(arguments, 1)));\n        },\n\n        yieldToOn: function (prop, thisValue) {\n            var args = this.args;\n            for (var i = 0, l = args.length; i < l; ++i) {\n                if (args[i] && typeof args[i][prop] === \"function\") {\n                    args[i][prop].apply(thisValue, slice.call(arguments, 2));\n                    return;\n                }\n            }\n            throwYieldError(this.proxy, \" cannot yield to '\" + prop +\n                \"' since no callback was passed.\", args);\n        },\n\n        toString: function () {\n            var callStr = this.proxy.toString() + \"(\";\n            var args = [];\n\n            for (var i = 0, l = this.args.length; i < l; ++i) {\n                args.push(sinon.format(this.args[i]));\n            }\n\n            callStr = callStr + args.join(\", \") + \")\";\n\n            if (typeof this.returnValue != \"undefined\") {\n                callStr += \" => \" + sinon.format(this.returnValue);\n            }\n\n            if (this.exception) {\n                callStr += \" !\" + this.exception.name;\n\n                if (this.exception.message) {\n                    callStr += \"(\" + this.exception.message + \")\";\n                }\n            }\n\n            return callStr;\n        }\n    };\n\n    callProto.invokeCallback = callProto.yield;\n\n    function createSpyCall(spy, thisValue, args, returnValue, exception, id) {\n        if (typeof id !== \"number\") {\n            throw new TypeError(\"Call id is not a number\");\n        }\n        var proxyCall = sinon.create(callProto);\n        proxyCall.proxy = spy;\n        proxyCall.thisValue = thisValue;\n        proxyCall.args = args;\n        proxyCall.returnValue = returnValue;\n        proxyCall.exception = exception;\n        proxyCall.callId = id;\n\n        return proxyCall;\n    }\n    createSpyCall.toString = callProto.toString; // used by mocks\n\n    sinon.spyCall = createSpyCall;\n\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], function(module) { module.exports = createSpyCall; });\n    } else if (commonJSModule) {\n        module.exports = createSpyCall;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n\n/**\n  * @depend ../sinon.js\n  * @depend call.js\n  */\n/*jslint eqeqeq: false, onevar: false, plusplus: false*/\n/*global module, require, sinon*/\n/**\n  * Spy functions\n  *\n  * @author Christian Johansen (christian@cjohansen.no)\n  * @license BSD\n  *\n  * Copyright (c) 2010-2013 Christian Johansen\n  */\n\n(function (sinon) {\n    var commonJSModule = typeof module !== \"undefined\" && module.exports && typeof require == \"function\";\n    var push = Array.prototype.push;\n    var slice = Array.prototype.slice;\n    var callId = 0;\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function spy(object, property) {\n        if (!property && typeof object == \"function\") {\n            return spy.create(object);\n        }\n\n        if (!object && !property) {\n            return spy.create(function () { });\n        }\n\n        var method = object[property];\n        return sinon.wrapMethod(object, property, spy.create(method));\n    }\n\n    function matchingFake(fakes, args, strict) {\n        if (!fakes) {\n            return;\n        }\n\n        for (var i = 0, l = fakes.length; i < l; i++) {\n            if (fakes[i].matches(args, strict)) {\n                return fakes[i];\n            }\n        }\n    }\n\n    function incrementCallCount() {\n        this.called = true;\n        this.callCount += 1;\n        this.notCalled = false;\n        this.calledOnce = this.callCount == 1;\n        this.calledTwice = this.callCount == 2;\n        this.calledThrice = this.callCount == 3;\n    }\n\n    function createCallProperties() {\n        this.firstCall = this.getCall(0);\n        this.secondCall = this.getCall(1);\n        this.thirdCall = this.getCall(2);\n        this.lastCall = this.getCall(this.callCount - 1);\n    }\n\n    var vars = \"a,b,c,d,e,f,g,h,i,j,k,l\";\n    function createProxy(func) {\n        // Retain the function length:\n        var p;\n        if (func.length) {\n            eval(\"p = (function proxy(\" + vars.substring(0, func.length * 2 - 1) +\n                \") { return p.invoke(func, this, slice.call(arguments)); });\");\n        }\n        else {\n            p = function proxy() {\n                return p.invoke(func, this, slice.call(arguments));\n            };\n        }\n        return p;\n    }\n\n    var uuid = 0;\n\n    // Public API\n    var spyApi = {\n        reset: function () {\n            this.called = false;\n            this.notCalled = true;\n            this.calledOnce = false;\n            this.calledTwice = false;\n            this.calledThrice = false;\n            this.callCount = 0;\n            this.firstCall = null;\n            this.secondCall = null;\n            this.thirdCall = null;\n            this.lastCall = null;\n            this.args = [];\n            this.returnValues = [];\n            this.thisValues = [];\n            this.exceptions = [];\n            this.callIds = [];\n            if (this.fakes) {\n                for (var i = 0; i < this.fakes.length; i++) {\n                    this.fakes[i].reset();\n                }\n            }\n        },\n\n        create: function create(func) {\n            var name;\n\n            if (typeof func != \"function\") {\n                func = function () { };\n            } else {\n                name = sinon.functionName(func);\n            }\n\n            var proxy = createProxy(func);\n\n            sinon.extend(proxy, spy);\n            delete proxy.create;\n            sinon.extend(proxy, func);\n\n            proxy.reset();\n            proxy.prototype = func.prototype;\n            proxy.displayName = name || \"spy\";\n            proxy.toString = sinon.functionToString;\n            proxy._create = sinon.spy.create;\n            proxy.id = \"spy#\" + uuid++;\n\n            return proxy;\n        },\n\n        invoke: function invoke(func, thisValue, args) {\n            var matching = matchingFake(this.fakes, args);\n            var exception, returnValue;\n\n            incrementCallCount.call(this);\n            push.call(this.thisValues, thisValue);\n            push.call(this.args, args);\n            push.call(this.callIds, callId++);\n\n            // Make call properties available from within the spied function:\n            createCallProperties.call(this);\n\n            try {\n                if (matching) {\n                    returnValue = matching.invoke(func, thisValue, args);\n                } else {\n                    returnValue = (this.func || func).apply(thisValue, args);\n                }\n\n                var thisCall = this.getCall(this.callCount - 1);\n                if (thisCall.calledWithNew() && typeof returnValue !== 'object') {\n                    returnValue = thisValue;\n                }\n            } catch (e) {\n                exception = e;\n            }\n\n            push.call(this.exceptions, exception);\n            push.call(this.returnValues, returnValue);\n\n            // Make return value and exception available in the calls:\n            createCallProperties.call(this);\n\n            if (exception !== undefined) {\n                throw exception;\n            }\n\n            return returnValue;\n        },\n\n        named: function named(name) {\n            this.displayName = name;\n            return this;\n        },\n\n        getCall: function getCall(i) {\n            if (i < 0 || i >= this.callCount) {\n                return null;\n            }\n\n            return sinon.spyCall(this, this.thisValues[i], this.args[i],\n                                    this.returnValues[i], this.exceptions[i],\n                                    this.callIds[i]);\n        },\n\n        getCalls: function () {\n            var calls = [];\n            var i;\n\n            for (i = 0; i < this.callCount; i++) {\n                calls.push(this.getCall(i));\n            }\n\n            return calls;\n        },\n\n        calledBefore: function calledBefore(spyFn) {\n            if (!this.called) {\n                return false;\n            }\n\n            if (!spyFn.called) {\n                return true;\n            }\n\n            return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];\n        },\n\n        calledAfter: function calledAfter(spyFn) {\n            if (!this.called || !spyFn.called) {\n                return false;\n            }\n\n            return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];\n        },\n\n        withArgs: function () {\n            var args = slice.call(arguments);\n\n            if (this.fakes) {\n                var match = matchingFake(this.fakes, args, true);\n\n                if (match) {\n                    return match;\n                }\n            } else {\n                this.fakes = [];\n            }\n\n            var original = this;\n            var fake = this._create();\n            fake.matchingAguments = args;\n            fake.parent = this;\n            push.call(this.fakes, fake);\n\n            fake.withArgs = function () {\n                return original.withArgs.apply(original, arguments);\n            };\n\n            for (var i = 0; i < this.args.length; i++) {\n                if (fake.matches(this.args[i])) {\n                    incrementCallCount.call(fake);\n                    push.call(fake.thisValues, this.thisValues[i]);\n                    push.call(fake.args, this.args[i]);\n                    push.call(fake.returnValues, this.returnValues[i]);\n                    push.call(fake.exceptions, this.exceptions[i]);\n                    push.call(fake.callIds, this.callIds[i]);\n                }\n            }\n            createCallProperties.call(fake);\n\n            return fake;\n        },\n\n        matches: function (args, strict) {\n            var margs = this.matchingAguments;\n\n            if (margs.length <= args.length &&\n                sinon.deepEqual(margs, args.slice(0, margs.length))) {\n                return !strict || margs.length == args.length;\n            }\n        },\n\n        printf: function (format) {\n            var spy = this;\n            var args = slice.call(arguments, 1);\n            var formatter;\n\n            return (format || \"\").replace(/%(.)/g, function (match, specifyer) {\n                formatter = spyApi.formatters[specifyer];\n\n                if (typeof formatter == \"function\") {\n                    return formatter.call(null, spy, args);\n                } else if (!isNaN(parseInt(specifyer, 10))) {\n                    return sinon.format(args[specifyer - 1]);\n                }\n\n                return \"%\" + specifyer;\n            });\n        }\n    };\n\n    function delegateToCalls(method, matchAny, actual, notCalled) {\n        spyApi[method] = function () {\n            if (!this.called) {\n                if (notCalled) {\n                    return notCalled.apply(this, arguments);\n                }\n                return false;\n            }\n\n            var currentCall;\n            var matches = 0;\n\n            for (var i = 0, l = this.callCount; i < l; i += 1) {\n                currentCall = this.getCall(i);\n\n                if (currentCall[actual || method].apply(currentCall, arguments)) {\n                    matches += 1;\n\n                    if (matchAny) {\n                        return true;\n                    }\n                }\n            }\n\n            return matches === this.callCount;\n        };\n    }\n\n    delegateToCalls(\"calledOn\", true);\n    delegateToCalls(\"alwaysCalledOn\", false, \"calledOn\");\n    delegateToCalls(\"calledWith\", true);\n    delegateToCalls(\"calledWithMatch\", true);\n    delegateToCalls(\"alwaysCalledWith\", false, \"calledWith\");\n    delegateToCalls(\"alwaysCalledWithMatch\", false, \"calledWithMatch\");\n    delegateToCalls(\"calledWithExactly\", true);\n    delegateToCalls(\"alwaysCalledWithExactly\", false, \"calledWithExactly\");\n    delegateToCalls(\"neverCalledWith\", false, \"notCalledWith\",\n        function () { return true; });\n    delegateToCalls(\"neverCalledWithMatch\", false, \"notCalledWithMatch\",\n        function () { return true; });\n    delegateToCalls(\"threw\", true);\n    delegateToCalls(\"alwaysThrew\", false, \"threw\");\n    delegateToCalls(\"returned\", true);\n    delegateToCalls(\"alwaysReturned\", false, \"returned\");\n    delegateToCalls(\"calledWithNew\", true);\n    delegateToCalls(\"alwaysCalledWithNew\", false, \"calledWithNew\");\n    delegateToCalls(\"callArg\", false, \"callArgWith\", function () {\n        throw new Error(this.toString() + \" cannot call arg since it was not yet invoked.\");\n    });\n    spyApi.callArgWith = spyApi.callArg;\n    delegateToCalls(\"callArgOn\", false, \"callArgOnWith\", function () {\n        throw new Error(this.toString() + \" cannot call arg since it was not yet invoked.\");\n    });\n    spyApi.callArgOnWith = spyApi.callArgOn;\n    delegateToCalls(\"yield\", false, \"yield\", function () {\n        throw new Error(this.toString() + \" cannot yield since it was not yet invoked.\");\n    });\n    // \"invokeCallback\" is an alias for \"yield\" since \"yield\" is invalid in strict mode.\n    spyApi.invokeCallback = spyApi.yield;\n    delegateToCalls(\"yieldOn\", false, \"yieldOn\", function () {\n        throw new Error(this.toString() + \" cannot yield since it was not yet invoked.\");\n    });\n    delegateToCalls(\"yieldTo\", false, \"yieldTo\", function (property) {\n        throw new Error(this.toString() + \" cannot yield to '\" + property +\n            \"' since it was not yet invoked.\");\n    });\n    delegateToCalls(\"yieldToOn\", false, \"yieldToOn\", function (property) {\n        throw new Error(this.toString() + \" cannot yield to '\" + property +\n            \"' since it was not yet invoked.\");\n    });\n\n    spyApi.formatters = {\n        \"c\": function (spy) {\n            return sinon.timesInWords(spy.callCount);\n        },\n\n        \"n\": function (spy) {\n            return spy.toString();\n        },\n\n        \"C\": function (spy) {\n            var calls = [];\n\n            for (var i = 0, l = spy.callCount; i < l; ++i) {\n                var stringifiedCall = \"    \" + spy.getCall(i).toString();\n                if (/\\n/.test(calls[i - 1])) {\n                    stringifiedCall = \"\\n\" + stringifiedCall;\n                }\n                push.call(calls, stringifiedCall);\n            }\n\n            return calls.length > 0 ? \"\\n\" + calls.join(\"\\n\") : \"\";\n        },\n\n        \"t\": function (spy) {\n            var objects = [];\n\n            for (var i = 0, l = spy.callCount; i < l; ++i) {\n                push.call(objects, sinon.format(spy.thisValues[i]));\n            }\n\n            return objects.join(\", \");\n        },\n\n        \"*\": function (spy, args) {\n            var formatted = [];\n\n            for (var i = 0, l = args.length; i < l; ++i) {\n                push.call(formatted, sinon.format(args[i]));\n            }\n\n            return formatted.join(\", \");\n        }\n    };\n\n    sinon.extend(spy, spyApi);\n\n    spy.spyCall = sinon.spyCall;\n    sinon.spy = spy;\n\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], function(module) { module.exports = spy; });\n    } else if (commonJSModule) {\n        module.exports = spy;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n * @depend ../sinon.js\n */\n/*jslint eqeqeq: false, onevar: false*/\n/*global module, require, sinon, process, setImmediate, setTimeout*/\n/**\n * Stub behavior\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @author Tim Fischbach (mail@timfischbach.de)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module !== \"undefined\" && module.exports && typeof require == \"function\";\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    var slice = Array.prototype.slice;\n    var join = Array.prototype.join;\n    var proto;\n\n    var nextTick = (function () {\n        if (typeof process === \"object\" && typeof process.nextTick === \"function\") {\n            return process.nextTick;\n        } else if (typeof setImmediate === \"function\") {\n            return setImmediate;\n        } else {\n            return function (callback) {\n                setTimeout(callback, 0);\n            };\n        }\n    })();\n\n    function throwsException(error, message) {\n        if (typeof error == \"string\") {\n            this.exception = new Error(message || \"\");\n            this.exception.name = error;\n        } else if (!error) {\n            this.exception = new Error(\"Error\");\n        } else {\n            this.exception = error;\n        }\n\n        return this;\n    }\n\n    function getCallback(behavior, args) {\n        var callArgAt = behavior.callArgAt;\n\n        if (callArgAt < 0) {\n            var callArgProp = behavior.callArgProp;\n\n            for (var i = 0, l = args.length; i < l; ++i) {\n                if (!callArgProp && typeof args[i] == \"function\") {\n                    return args[i];\n                }\n\n                if (callArgProp && args[i] &&\n                    typeof args[i][callArgProp] == \"function\") {\n                    return args[i][callArgProp];\n                }\n            }\n\n            return null;\n        }\n\n        return args[callArgAt];\n    }\n\n    function getCallbackError(behavior, func, args) {\n        if (behavior.callArgAt < 0) {\n            var msg;\n\n            if (behavior.callArgProp) {\n                msg = sinon.functionName(behavior.stub) +\n                    \" expected to yield to '\" + behavior.callArgProp +\n                    \"', but no object with such a property was passed.\";\n            } else {\n                msg = sinon.functionName(behavior.stub) +\n                    \" expected to yield, but no callback was passed.\";\n            }\n\n            if (args.length > 0) {\n                msg += \" Received [\" + join.call(args, \", \") + \"]\";\n            }\n\n            return msg;\n        }\n\n        return \"argument at index \" + behavior.callArgAt + \" is not a function: \" + func;\n    }\n\n    function callCallback(behavior, args) {\n        if (typeof behavior.callArgAt == \"number\") {\n            var func = getCallback(behavior, args);\n\n            if (typeof func != \"function\") {\n                throw new TypeError(getCallbackError(behavior, func, args));\n            }\n\n            if (behavior.callbackAsync) {\n                nextTick(function() {\n                    func.apply(behavior.callbackContext, behavior.callbackArguments);\n                });\n            } else {\n                func.apply(behavior.callbackContext, behavior.callbackArguments);\n            }\n        }\n    }\n\n    proto = {\n        create: function(stub) {\n            var behavior = sinon.extend({}, sinon.behavior);\n            delete behavior.create;\n            behavior.stub = stub;\n\n            return behavior;\n        },\n\n        isPresent: function() {\n            return (typeof this.callArgAt == 'number' ||\n                    this.exception ||\n                    typeof this.returnArgAt == 'number' ||\n                    this.returnThis ||\n                    this.returnValueDefined);\n        },\n\n        invoke: function(context, args) {\n            callCallback(this, args);\n\n            if (this.exception) {\n                throw this.exception;\n            } else if (typeof this.returnArgAt == 'number') {\n                return args[this.returnArgAt];\n            } else if (this.returnThis) {\n                return context;\n            }\n\n            return this.returnValue;\n        },\n\n        onCall: function(index) {\n            return this.stub.onCall(index);\n        },\n\n        onFirstCall: function() {\n            return this.stub.onFirstCall();\n        },\n\n        onSecondCall: function() {\n            return this.stub.onSecondCall();\n        },\n\n        onThirdCall: function() {\n            return this.stub.onThirdCall();\n        },\n\n        withArgs: function(/* arguments */) {\n            throw new Error('Defining a stub by invoking \"stub.onCall(...).withArgs(...)\" is not supported. ' +\n                            'Use \"stub.withArgs(...).onCall(...)\" to define sequential behavior for calls with certain arguments.');\n        },\n\n        callsArg: function callsArg(pos) {\n            if (typeof pos != \"number\") {\n                throw new TypeError(\"argument index is not number\");\n            }\n\n            this.callArgAt = pos;\n            this.callbackArguments = [];\n            this.callbackContext = undefined;\n            this.callArgProp = undefined;\n            this.callbackAsync = false;\n\n            return this;\n        },\n\n        callsArgOn: function callsArgOn(pos, context) {\n            if (typeof pos != \"number\") {\n                throw new TypeError(\"argument index is not number\");\n            }\n            if (typeof context != \"object\") {\n                throw new TypeError(\"argument context is not an object\");\n            }\n\n            this.callArgAt = pos;\n            this.callbackArguments = [];\n            this.callbackContext = context;\n            this.callArgProp = undefined;\n            this.callbackAsync = false;\n\n            return this;\n        },\n\n        callsArgWith: function callsArgWith(pos) {\n            if (typeof pos != \"number\") {\n                throw new TypeError(\"argument index is not number\");\n            }\n\n            this.callArgAt = pos;\n            this.callbackArguments = slice.call(arguments, 1);\n            this.callbackContext = undefined;\n            this.callArgProp = undefined;\n            this.callbackAsync = false;\n\n            return this;\n        },\n\n        callsArgOnWith: function callsArgWith(pos, context) {\n            if (typeof pos != \"number\") {\n                throw new TypeError(\"argument index is not number\");\n            }\n            if (typeof context != \"object\") {\n                throw new TypeError(\"argument context is not an object\");\n            }\n\n            this.callArgAt = pos;\n            this.callbackArguments = slice.call(arguments, 2);\n            this.callbackContext = context;\n            this.callArgProp = undefined;\n            this.callbackAsync = false;\n\n            return this;\n        },\n\n        yields: function () {\n            this.callArgAt = -1;\n            this.callbackArguments = slice.call(arguments, 0);\n            this.callbackContext = undefined;\n            this.callArgProp = undefined;\n            this.callbackAsync = false;\n\n            return this;\n        },\n\n        yieldsOn: function (context) {\n            if (typeof context != \"object\") {\n                throw new TypeError(\"argument context is not an object\");\n            }\n\n            this.callArgAt = -1;\n            this.callbackArguments = slice.call(arguments, 1);\n            this.callbackContext = context;\n            this.callArgProp = undefined;\n            this.callbackAsync = false;\n\n            return this;\n        },\n\n        yieldsTo: function (prop) {\n            this.callArgAt = -1;\n            this.callbackArguments = slice.call(arguments, 1);\n            this.callbackContext = undefined;\n            this.callArgProp = prop;\n            this.callbackAsync = false;\n\n            return this;\n        },\n\n        yieldsToOn: function (prop, context) {\n            if (typeof context != \"object\") {\n                throw new TypeError(\"argument context is not an object\");\n            }\n\n            this.callArgAt = -1;\n            this.callbackArguments = slice.call(arguments, 2);\n            this.callbackContext = context;\n            this.callArgProp = prop;\n            this.callbackAsync = false;\n\n            return this;\n        },\n\n\n        \"throws\": throwsException,\n        throwsException: throwsException,\n\n        returns: function returns(value) {\n            this.returnValue = value;\n            this.returnValueDefined = true;\n\n            return this;\n        },\n\n        returnsArg: function returnsArg(pos) {\n            if (typeof pos != \"number\") {\n                throw new TypeError(\"argument index is not number\");\n            }\n\n            this.returnArgAt = pos;\n\n            return this;\n        },\n\n        returnsThis: function returnsThis() {\n            this.returnThis = true;\n\n            return this;\n        }\n    };\n\n    // create asynchronous versions of callsArg* and yields* methods\n    for (var method in proto) {\n        // need to avoid creating anotherasync versions of the newly added async methods\n        if (proto.hasOwnProperty(method) &&\n            method.match(/^(callsArg|yields)/) &&\n            !method.match(/Async/)) {\n            proto[method + 'Async'] = (function (syncFnName) {\n                return function () {\n                    var result = this[syncFnName].apply(this, arguments);\n                    this.callbackAsync = true;\n                    return result;\n                };\n            })(method);\n        }\n    }\n\n    sinon.behavior = proto;\n\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], function(module) { module.exports = proto; });\n    } else if (commonJSModule) {\n        module.exports = proto;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n * @depend ../sinon.js\n * @depend spy.js\n * @depend behavior.js\n */\n/*jslint eqeqeq: false, onevar: false*/\n/*global module, require, sinon*/\n/**\n * Stub functions\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module !== \"undefined\" && module.exports && typeof require == \"function\";\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function stub(object, property, func) {\n        if (!!func && typeof func != \"function\") {\n            throw new TypeError(\"Custom stub should be function\");\n        }\n\n        var wrapper;\n\n        if (func) {\n            wrapper = sinon.spy && sinon.spy.create ? sinon.spy.create(func) : func;\n        } else {\n            wrapper = stub.create();\n        }\n\n        if (!object && typeof property === \"undefined\") {\n            return sinon.stub.create();\n        }\n\n        if (typeof property === \"undefined\" && typeof object == \"object\") {\n            for (var prop in object) {\n                if (typeof object[prop] === \"function\") {\n                    stub(object, prop);\n                }\n            }\n\n            return object;\n        }\n\n        return sinon.wrapMethod(object, property, wrapper);\n    }\n\n    function getDefaultBehavior(stub) {\n        return stub.defaultBehavior || getParentBehaviour(stub) || sinon.behavior.create(stub);\n    }\n\n    function getParentBehaviour(stub) {\n        return (stub.parent && getCurrentBehavior(stub.parent));\n    }\n\n    function getCurrentBehavior(stub) {\n        var behavior = stub.behaviors[stub.callCount - 1];\n        return behavior && behavior.isPresent() ? behavior : getDefaultBehavior(stub);\n    }\n\n    var uuid = 0;\n\n    sinon.extend(stub, (function () {\n        var proto = {\n            create: function create() {\n                var functionStub = function () {\n                    return getCurrentBehavior(functionStub).invoke(this, arguments);\n                };\n\n                functionStub.id = \"stub#\" + uuid++;\n                var orig = functionStub;\n                functionStub = sinon.spy.create(functionStub);\n                functionStub.func = orig;\n\n                sinon.extend(functionStub, stub);\n                functionStub._create = sinon.stub.create;\n                functionStub.displayName = \"stub\";\n                functionStub.toString = sinon.functionToString;\n\n                functionStub.defaultBehavior = null;\n                functionStub.behaviors = [];\n\n                return functionStub;\n            },\n\n            resetBehavior: function () {\n                var i;\n\n                this.defaultBehavior = null;\n                this.behaviors = [];\n\n                delete this.returnValue;\n                delete this.returnArgAt;\n                this.returnThis = false;\n\n                if (this.fakes) {\n                    for (i = 0; i < this.fakes.length; i++) {\n                        this.fakes[i].resetBehavior();\n                    }\n                }\n            },\n\n            onCall: function(index) {\n                if (!this.behaviors[index]) {\n                    this.behaviors[index] = sinon.behavior.create(this);\n                }\n\n                return this.behaviors[index];\n            },\n\n            onFirstCall: function() {\n                return this.onCall(0);\n            },\n\n            onSecondCall: function() {\n                return this.onCall(1);\n            },\n\n            onThirdCall: function() {\n                return this.onCall(2);\n            }\n        };\n\n        for (var method in sinon.behavior) {\n            if (sinon.behavior.hasOwnProperty(method) &&\n                !proto.hasOwnProperty(method) &&\n                method != 'create' &&\n                method != 'withArgs' &&\n                method != 'invoke') {\n                proto[method] = (function(behaviorMethod) {\n                    return function() {\n                        this.defaultBehavior = this.defaultBehavior || sinon.behavior.create(this);\n                        this.defaultBehavior[behaviorMethod].apply(this.defaultBehavior, arguments);\n                        return this;\n                    };\n                }(method));\n            }\n        }\n\n        return proto;\n    }()));\n\n    sinon.stub = stub;\n\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], function(module) { module.exports = stub; });\n    } else if (commonJSModule) {\n        module.exports = stub;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n * @depend ../sinon.js\n * @depend stub.js\n */\n/*jslint eqeqeq: false, onevar: false, nomen: false*/\n/*global module, require, sinon*/\n/**\n * Mock functions.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module !== \"undefined\" && module.exports && typeof require == \"function\";\n    var push = [].push;\n    var match;\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    match = sinon.match;\n\n    if (!match && commonJSModule) {\n        match = require(\"./match\");\n    }\n\n    function mock(object) {\n        if (!object) {\n            return sinon.expectation.create(\"Anonymous mock\");\n        }\n\n        return mock.create(object);\n    }\n\n    sinon.mock = mock;\n\n    sinon.extend(mock, (function () {\n        function each(collection, callback) {\n            if (!collection) {\n                return;\n            }\n\n            for (var i = 0, l = collection.length; i < l; i += 1) {\n                callback(collection[i]);\n            }\n        }\n\n        return {\n            create: function create(object) {\n                if (!object) {\n                    throw new TypeError(\"object is null\");\n                }\n\n                var mockObject = sinon.extend({}, mock);\n                mockObject.object = object;\n                delete mockObject.create;\n\n                return mockObject;\n            },\n\n            expects: function expects(method) {\n                if (!method) {\n                    throw new TypeError(\"method is falsy\");\n                }\n\n                if (!this.expectations) {\n                    this.expectations = {};\n                    this.proxies = [];\n                }\n\n                if (!this.expectations[method]) {\n                    this.expectations[method] = [];\n                    var mockObject = this;\n\n                    sinon.wrapMethod(this.object, method, function () {\n                        return mockObject.invokeMethod(method, this, arguments);\n                    });\n\n                    push.call(this.proxies, method);\n                }\n\n                var expectation = sinon.expectation.create(method);\n                push.call(this.expectations[method], expectation);\n\n                return expectation;\n            },\n\n            restore: function restore() {\n                var object = this.object;\n\n                each(this.proxies, function (proxy) {\n                    if (typeof object[proxy].restore == \"function\") {\n                        object[proxy].restore();\n                    }\n                });\n            },\n\n            verify: function verify() {\n                var expectations = this.expectations || {};\n                var messages = [], met = [];\n\n                each(this.proxies, function (proxy) {\n                    each(expectations[proxy], function (expectation) {\n                        if (!expectation.met()) {\n                            push.call(messages, expectation.toString());\n                        } else {\n                            push.call(met, expectation.toString());\n                        }\n                    });\n                });\n\n                this.restore();\n\n                if (messages.length > 0) {\n                    sinon.expectation.fail(messages.concat(met).join(\"\\n\"));\n                } else {\n                    sinon.expectation.pass(messages.concat(met).join(\"\\n\"));\n                }\n\n                return true;\n            },\n\n            invokeMethod: function invokeMethod(method, thisValue, args) {\n                var expectations = this.expectations && this.expectations[method];\n                var length = expectations && expectations.length || 0, i;\n\n                for (i = 0; i < length; i += 1) {\n                    if (!expectations[i].met() &&\n                        expectations[i].allowsCall(thisValue, args)) {\n                        return expectations[i].apply(thisValue, args);\n                    }\n                }\n\n                var messages = [], available, exhausted = 0;\n\n                for (i = 0; i < length; i += 1) {\n                    if (expectations[i].allowsCall(thisValue, args)) {\n                        available = available || expectations[i];\n                    } else {\n                        exhausted += 1;\n                    }\n                    push.call(messages, \"    \" + expectations[i].toString());\n                }\n\n                if (exhausted === 0) {\n                    return available.apply(thisValue, args);\n                }\n\n                messages.unshift(\"Unexpected call: \" + sinon.spyCall.toString.call({\n                    proxy: method,\n                    args: args\n                }));\n\n                sinon.expectation.fail(messages.join(\"\\n\"));\n            }\n        };\n    }()));\n\n    var times = sinon.timesInWords;\n\n    sinon.expectation = (function () {\n        var slice = Array.prototype.slice;\n        var _invoke = sinon.spy.invoke;\n\n        function callCountInWords(callCount) {\n            if (callCount == 0) {\n                return \"never called\";\n            } else {\n                return \"called \" + times(callCount);\n            }\n        }\n\n        function expectedCallCountInWords(expectation) {\n            var min = expectation.minCalls;\n            var max = expectation.maxCalls;\n\n            if (typeof min == \"number\" && typeof max == \"number\") {\n                var str = times(min);\n\n                if (min != max) {\n                    str = \"at least \" + str + \" and at most \" + times(max);\n                }\n\n                return str;\n            }\n\n            if (typeof min == \"number\") {\n                return \"at least \" + times(min);\n            }\n\n            return \"at most \" + times(max);\n        }\n\n        function receivedMinCalls(expectation) {\n            var hasMinLimit = typeof expectation.minCalls == \"number\";\n            return !hasMinLimit || expectation.callCount >= expectation.minCalls;\n        }\n\n        function receivedMaxCalls(expectation) {\n            if (typeof expectation.maxCalls != \"number\") {\n                return false;\n            }\n\n            return expectation.callCount == expectation.maxCalls;\n        }\n\n        function verifyMatcher(possibleMatcher, arg){\n            if (match && match.isMatcher(possibleMatcher)) {\n                return possibleMatcher.test(arg);\n            } else {\n                return true;\n            }\n        }\n\n        return {\n            minCalls: 1,\n            maxCalls: 1,\n\n            create: function create(methodName) {\n                var expectation = sinon.extend(sinon.stub.create(), sinon.expectation);\n                delete expectation.create;\n                expectation.method = methodName;\n\n                return expectation;\n            },\n\n            invoke: function invoke(func, thisValue, args) {\n                this.verifyCallAllowed(thisValue, args);\n\n                return _invoke.apply(this, arguments);\n            },\n\n            atLeast: function atLeast(num) {\n                if (typeof num != \"number\") {\n                    throw new TypeError(\"'\" + num + \"' is not number\");\n                }\n\n                if (!this.limitsSet) {\n                    this.maxCalls = null;\n                    this.limitsSet = true;\n                }\n\n                this.minCalls = num;\n\n                return this;\n            },\n\n            atMost: function atMost(num) {\n                if (typeof num != \"number\") {\n                    throw new TypeError(\"'\" + num + \"' is not number\");\n                }\n\n                if (!this.limitsSet) {\n                    this.minCalls = null;\n                    this.limitsSet = true;\n                }\n\n                this.maxCalls = num;\n\n                return this;\n            },\n\n            never: function never() {\n                return this.exactly(0);\n            },\n\n            once: function once() {\n                return this.exactly(1);\n            },\n\n            twice: function twice() {\n                return this.exactly(2);\n            },\n\n            thrice: function thrice() {\n                return this.exactly(3);\n            },\n\n            exactly: function exactly(num) {\n                if (typeof num != \"number\") {\n                    throw new TypeError(\"'\" + num + \"' is not a number\");\n                }\n\n                this.atLeast(num);\n                return this.atMost(num);\n            },\n\n            met: function met() {\n                return !this.failed && receivedMinCalls(this);\n            },\n\n            verifyCallAllowed: function verifyCallAllowed(thisValue, args) {\n                if (receivedMaxCalls(this)) {\n                    this.failed = true;\n                    sinon.expectation.fail(this.method + \" already called \" + times(this.maxCalls));\n                }\n\n                if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n                    sinon.expectation.fail(this.method + \" called with \" + thisValue + \" as thisValue, expected \" +\n                        this.expectedThis);\n                }\n\n                if (!(\"expectedArguments\" in this)) {\n                    return;\n                }\n\n                if (!args) {\n                    sinon.expectation.fail(this.method + \" received no arguments, expected \" +\n                        sinon.format(this.expectedArguments));\n                }\n\n                if (args.length < this.expectedArguments.length) {\n                    sinon.expectation.fail(this.method + \" received too few arguments (\" + sinon.format(args) +\n                        \"), expected \" + sinon.format(this.expectedArguments));\n                }\n\n                if (this.expectsExactArgCount &&\n                    args.length != this.expectedArguments.length) {\n                    sinon.expectation.fail(this.method + \" received too many arguments (\" + sinon.format(args) +\n                        \"), expected \" + sinon.format(this.expectedArguments));\n                }\n\n                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {\n\n                    if (!verifyMatcher(this.expectedArguments[i],args[i])) {\n                        sinon.expectation.fail(this.method + \" received wrong arguments \" + sinon.format(args) +\n                            \", didn't match \" + this.expectedArguments.toString());\n                    }\n\n                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {\n                        sinon.expectation.fail(this.method + \" received wrong arguments \" + sinon.format(args) +\n                            \", expected \" + sinon.format(this.expectedArguments));\n                    }\n                }\n            },\n\n            allowsCall: function allowsCall(thisValue, args) {\n                if (this.met() && receivedMaxCalls(this)) {\n                    return false;\n                }\n\n                if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n                    return false;\n                }\n\n                if (!(\"expectedArguments\" in this)) {\n                    return true;\n                }\n\n                args = args || [];\n\n                if (args.length < this.expectedArguments.length) {\n                    return false;\n                }\n\n                if (this.expectsExactArgCount &&\n                    args.length != this.expectedArguments.length) {\n                    return false;\n                }\n\n                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {\n                    if (!verifyMatcher(this.expectedArguments[i],args[i])) {\n                        return false;\n                    }\n\n                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n\n            withArgs: function withArgs() {\n                this.expectedArguments = slice.call(arguments);\n                return this;\n            },\n\n            withExactArgs: function withExactArgs() {\n                this.withArgs.apply(this, arguments);\n                this.expectsExactArgCount = true;\n                return this;\n            },\n\n            on: function on(thisValue) {\n                this.expectedThis = thisValue;\n                return this;\n            },\n\n            toString: function () {\n                var args = (this.expectedArguments || []).slice();\n\n                if (!this.expectsExactArgCount) {\n                    push.call(args, \"[...]\");\n                }\n\n                var callStr = sinon.spyCall.toString.call({\n                    proxy: this.method || \"anonymous mock expectation\",\n                    args: args\n                });\n\n                var message = callStr.replace(\", [...\", \"[, ...\") + \" \" +\n                    expectedCallCountInWords(this);\n\n                if (this.met()) {\n                    return \"Expectation met: \" + message;\n                }\n\n                return \"Expected \" + message + \" (\" +\n                    callCountInWords(this.callCount) + \")\";\n            },\n\n            verify: function verify() {\n                if (!this.met()) {\n                    sinon.expectation.fail(this.toString());\n                } else {\n                    sinon.expectation.pass(this.toString());\n                }\n\n                return true;\n            },\n\n            pass: function(message) {\n              sinon.assert.pass(message);\n            },\n            fail: function (message) {\n                var exception = new Error(message);\n                exception.name = \"ExpectationError\";\n\n                throw exception;\n            }\n        };\n    }());\n\n    sinon.mock = mock;\n\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], function(module) { module.exports = mock; });\n    } else if (commonJSModule) {\n        module.exports = mock;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n * @depend ../sinon.js\n * @depend stub.js\n * @depend mock.js\n */\n/*jslint eqeqeq: false, onevar: false, forin: true*/\n/*global module, require, sinon*/\n/**\n * Collections of stubs, spies and mocks.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module !== \"undefined\" && module.exports && typeof require == \"function\";\n    var push = [].push;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function getFakes(fakeCollection) {\n        if (!fakeCollection.fakes) {\n            fakeCollection.fakes = [];\n        }\n\n        return fakeCollection.fakes;\n    }\n\n    function each(fakeCollection, method) {\n        var fakes = getFakes(fakeCollection);\n\n        for (var i = 0, l = fakes.length; i < l; i += 1) {\n            if (typeof fakes[i][method] == \"function\") {\n                fakes[i][method]();\n            }\n        }\n    }\n\n    function compact(fakeCollection) {\n        var fakes = getFakes(fakeCollection);\n        var i = 0;\n        while (i < fakes.length) {\n          fakes.splice(i, 1);\n        }\n    }\n\n    var collection = {\n        verify: function resolve() {\n            each(this, \"verify\");\n        },\n\n        restore: function restore() {\n            each(this, \"restore\");\n            compact(this);\n        },\n\n        verifyAndRestore: function verifyAndRestore() {\n            var exception;\n\n            try {\n                this.verify();\n            } catch (e) {\n                exception = e;\n            }\n\n            this.restore();\n\n            if (exception) {\n                throw exception;\n            }\n        },\n\n        add: function add(fake) {\n            push.call(getFakes(this), fake);\n            return fake;\n        },\n\n        spy: function spy() {\n            return this.add(sinon.spy.apply(sinon, arguments));\n        },\n\n        stub: function stub(object, property, value) {\n            if (property) {\n                var original = object[property];\n\n                if (typeof original != \"function\") {\n                    if (!hasOwnProperty.call(object, property)) {\n                        throw new TypeError(\"Cannot stub non-existent own property \" + property);\n                    }\n\n                    object[property] = value;\n\n                    return this.add({\n                        restore: function () {\n                            object[property] = original;\n                        }\n                    });\n                }\n            }\n            if (!property && !!object && typeof object == \"object\") {\n                var stubbedObj = sinon.stub.apply(sinon, arguments);\n\n                for (var prop in stubbedObj) {\n                    if (typeof stubbedObj[prop] === \"function\") {\n                        this.add(stubbedObj[prop]);\n                    }\n                }\n\n                return stubbedObj;\n            }\n\n            return this.add(sinon.stub.apply(sinon, arguments));\n        },\n\n        mock: function mock() {\n            return this.add(sinon.mock.apply(sinon, arguments));\n        },\n\n        inject: function inject(obj) {\n            var col = this;\n\n            obj.spy = function () {\n                return col.spy.apply(col, arguments);\n            };\n\n            obj.stub = function () {\n                return col.stub.apply(col, arguments);\n            };\n\n            obj.mock = function () {\n                return col.mock.apply(col, arguments);\n            };\n\n            return obj;\n        }\n    };\n\n    sinon.collection = collection;\n\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], function(module) { module.exports = collection; });\n    } else if (commonJSModule) {\n        module.exports = collection;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/*jslint eqeqeq: false, plusplus: false, evil: true, onevar: false, browser: true, forin: false*/\n/*global module, require, window*/\n/**\n * Fake timer API\n * setTimeout\n * setInterval\n * clearTimeout\n * clearInterval\n * tick\n * reset\n * Date\n *\n * Inspired by jsUnitMockTimeOut from JsUnit\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\nif (typeof sinon == \"undefined\") {\n    var sinon = {};\n}\n\n(function (global) {\n    // node expects setTimeout/setInterval to return a fn object w/ .ref()/.unref()\n    // browsers, a number.\n    // see https://github.com/cjohansen/Sinon.JS/pull/436\n    var timeoutResult = setTimeout(function() {}, 0);\n    var addTimerReturnsObject = typeof timeoutResult === 'object';\n    clearTimeout(timeoutResult);\n\n    var id = 1;\n\n    function addTimer(args, recurring) {\n        if (args.length === 0) {\n            throw new Error(\"Function requires at least 1 parameter\");\n        }\n\n        if (typeof args[0] === \"undefined\") {\n            throw new Error(\"Callback must be provided to timer calls\");\n        }\n\n        var toId = id++;\n        var delay = args[1] || 0;\n\n        if (!this.timeouts) {\n            this.timeouts = {};\n        }\n\n        this.timeouts[toId] = {\n            id: toId,\n            func: args[0],\n            callAt: this.now + delay,\n            invokeArgs: Array.prototype.slice.call(args, 2)\n        };\n\n        if (recurring === true) {\n            this.timeouts[toId].interval = delay;\n        }\n\n        if (addTimerReturnsObject) {\n            return {\n                id: toId,\n                ref: function() {},\n                unref: function() {}\n            };\n        }\n        else {\n            return toId;\n        }\n    }\n\n    function parseTime(str) {\n        if (!str) {\n            return 0;\n        }\n\n        var strings = str.split(\":\");\n        var l = strings.length, i = l;\n        var ms = 0, parsed;\n\n        if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\n            throw new Error(\"tick only understands numbers and 'h:m:s'\");\n        }\n\n        while (i--) {\n            parsed = parseInt(strings[i], 10);\n\n            if (parsed >= 60) {\n                throw new Error(\"Invalid time \" + str);\n            }\n\n            ms += parsed * Math.pow(60, (l - i - 1));\n        }\n\n        return ms * 1000;\n    }\n\n    function createObject(object) {\n        var newObject;\n\n        if (Object.create) {\n            newObject = Object.create(object);\n        } else {\n            var F = function () {};\n            F.prototype = object;\n            newObject = new F();\n        }\n\n        newObject.Date.clock = newObject;\n        return newObject;\n    }\n\n    sinon.clock = {\n        now: 0,\n\n        create: function create(now) {\n            var clock = createObject(this);\n\n            if (typeof now == \"number\") {\n                clock.now = now;\n            }\n\n            if (!!now && typeof now == \"object\") {\n                throw new TypeError(\"now should be milliseconds since UNIX epoch\");\n            }\n\n            return clock;\n        },\n\n        setTimeout: function setTimeout(callback, timeout) {\n            return addTimer.call(this, arguments, false);\n        },\n\n        clearTimeout: function clearTimeout(timerId) {\n            if (!timerId) {\n                // null appears to be allowed in most browsers, and appears to be relied upon by some libraries, like Bootstrap carousel\n                return;\n            }\n            if (!this.timeouts) {\n                this.timeouts = [];\n            }\n            // in Node, timerId is an object with .ref()/.unref(), and\n            // its .id field is the actual timer id.\n            if (typeof timerId === 'object') {\n              timerId = timerId.id\n            }\n            if (timerId in this.timeouts) {\n                delete this.timeouts[timerId];\n            }\n        },\n\n        setInterval: function setInterval(callback, timeout) {\n            return addTimer.call(this, arguments, true);\n        },\n\n        clearInterval: function clearInterval(timerId) {\n            this.clearTimeout(timerId);\n        },\n\n        setImmediate: function setImmediate(callback) {\n            var passThruArgs = Array.prototype.slice.call(arguments, 1);\n\n            return addTimer.call(this, [callback, 0].concat(passThruArgs), false);\n        },\n\n        clearImmediate: function clearImmediate(timerId) {\n            this.clearTimeout(timerId);\n        },\n\n        tick: function tick(ms) {\n            ms = typeof ms == \"number\" ? ms : parseTime(ms);\n            var tickFrom = this.now, tickTo = this.now + ms, previous = this.now;\n            var timer = this.firstTimerInRange(tickFrom, tickTo);\n\n            var firstException;\n            while (timer && tickFrom <= tickTo) {\n                if (this.timeouts[timer.id]) {\n                    tickFrom = this.now = timer.callAt;\n                    try {\n                      this.callTimer(timer);\n                    } catch (e) {\n                      firstException = firstException || e;\n                    }\n                }\n\n                timer = this.firstTimerInRange(previous, tickTo);\n                previous = tickFrom;\n            }\n\n            this.now = tickTo;\n\n            if (firstException) {\n              throw firstException;\n            }\n\n            return this.now;\n        },\n\n        firstTimerInRange: function (from, to) {\n            var timer, smallest = null, originalTimer;\n\n            for (var id in this.timeouts) {\n                if (this.timeouts.hasOwnProperty(id)) {\n                    if (this.timeouts[id].callAt < from || this.timeouts[id].callAt > to) {\n                        continue;\n                    }\n\n                    if (smallest === null || this.timeouts[id].callAt < smallest) {\n                        originalTimer = this.timeouts[id];\n                        smallest = this.timeouts[id].callAt;\n\n                        timer = {\n                            func: this.timeouts[id].func,\n                            callAt: this.timeouts[id].callAt,\n                            interval: this.timeouts[id].interval,\n                            id: this.timeouts[id].id,\n                            invokeArgs: this.timeouts[id].invokeArgs\n                        };\n                    }\n                }\n            }\n\n            return timer || null;\n        },\n\n        callTimer: function (timer) {\n            if (typeof timer.interval == \"number\") {\n                this.timeouts[timer.id].callAt += timer.interval;\n            } else {\n                delete this.timeouts[timer.id];\n            }\n\n            try {\n                if (typeof timer.func == \"function\") {\n                    timer.func.apply(null, timer.invokeArgs);\n                } else {\n                    eval(timer.func);\n                }\n            } catch (e) {\n              var exception = e;\n            }\n\n            if (!this.timeouts[timer.id]) {\n                if (exception) {\n                  throw exception;\n                }\n                return;\n            }\n\n            if (exception) {\n              throw exception;\n            }\n        },\n\n        reset: function reset() {\n            this.timeouts = {};\n        },\n\n        Date: (function () {\n            var NativeDate = Date;\n\n            function ClockDate(year, month, date, hour, minute, second, ms) {\n                // Defensive and verbose to avoid potential harm in passing\n                // explicit undefined when user does not pass argument\n                switch (arguments.length) {\n                case 0:\n                    return new NativeDate(ClockDate.clock.now);\n                case 1:\n                    return new NativeDate(year);\n                case 2:\n                    return new NativeDate(year, month);\n                case 3:\n                    return new NativeDate(year, month, date);\n                case 4:\n                    return new NativeDate(year, month, date, hour);\n                case 5:\n                    return new NativeDate(year, month, date, hour, minute);\n                case 6:\n                    return new NativeDate(year, month, date, hour, minute, second);\n                default:\n                    return new NativeDate(year, month, date, hour, minute, second, ms);\n                }\n            }\n\n            return mirrorDateProperties(ClockDate, NativeDate);\n        }())\n    };\n\n    function mirrorDateProperties(target, source) {\n        if (source.now) {\n            target.now = function now() {\n                return target.clock.now;\n            };\n        } else {\n            delete target.now;\n        }\n\n        if (source.toSource) {\n            target.toSource = function toSource() {\n                return source.toSource();\n            };\n        } else {\n            delete target.toSource;\n        }\n\n        target.toString = function toString() {\n            return source.toString();\n        };\n\n        target.prototype = source.prototype;\n        target.parse = source.parse;\n        target.UTC = source.UTC;\n        target.prototype.toUTCString = source.prototype.toUTCString;\n\n        for (var prop in source) {\n            if (source.hasOwnProperty(prop)) {\n                target[prop] = source[prop];\n            }\n        }\n\n        return target;\n    }\n\n    var methods = [\"Date\", \"setTimeout\", \"setInterval\",\n                   \"clearTimeout\", \"clearInterval\"];\n\n    if (typeof global.setImmediate !== \"undefined\") {\n        methods.push(\"setImmediate\");\n    }\n\n    if (typeof global.clearImmediate !== \"undefined\") {\n        methods.push(\"clearImmediate\");\n    }\n\n    function restore() {\n        var method;\n\n        for (var i = 0, l = this.methods.length; i < l; i++) {\n            method = this.methods[i];\n\n            if (global[method].hadOwnProperty) {\n                global[method] = this[\"_\" + method];\n            } else {\n                try {\n                    delete global[method];\n                } catch (e) {}\n            }\n        }\n\n        // Prevent multiple executions which will completely remove these props\n        this.methods = [];\n    }\n\n    function stubGlobal(method, clock) {\n        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(global, method);\n        clock[\"_\" + method] = global[method];\n\n        if (method == \"Date\") {\n            var date = mirrorDateProperties(clock[method], global[method]);\n            global[method] = date;\n        } else {\n            global[method] = function () {\n                return clock[method].apply(clock, arguments);\n            };\n\n            for (var prop in clock[method]) {\n                if (clock[method].hasOwnProperty(prop)) {\n                    global[method][prop] = clock[method][prop];\n                }\n            }\n        }\n\n        global[method].clock = clock;\n    }\n\n    sinon.useFakeTimers = function useFakeTimers(now) {\n        var clock = sinon.clock.create(now);\n        clock.restore = restore;\n        clock.methods = Array.prototype.slice.call(arguments,\n                                                   typeof now == \"number\" ? 1 : 0);\n\n        if (clock.methods.length === 0) {\n            clock.methods = methods;\n        }\n\n        for (var i = 0, l = clock.methods.length; i < l; i++) {\n            stubGlobal(clock.methods[i], clock);\n        }\n\n        return clock;\n    };\n}(typeof global != \"undefined\" && typeof global !== \"function\" ? global : this));\n\nsinon.timers = {\n    setTimeout: setTimeout,\n    clearTimeout: clearTimeout,\n    setImmediate: (typeof setImmediate !== \"undefined\" ? setImmediate : undefined),\n    clearImmediate: (typeof clearImmediate !== \"undefined\" ? clearImmediate: undefined),\n    setInterval: setInterval,\n    clearInterval: clearInterval,\n    Date: Date\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = sinon;\n}\n\n/*jslint eqeqeq: false, onevar: false*/\n/*global sinon, module, require, ActiveXObject, XMLHttpRequest, DOMParser*/\n/**\n * Minimal Event interface implementation\n *\n * Original implementation by Sven Fuchs: https://gist.github.com/995028\n * Modifications and tests by Christian Johansen.\n *\n * @author Sven Fuchs (svenfuchs@artweb-design.de)\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2011 Sven Fuchs, Christian Johansen\n */\n\nif (typeof sinon == \"undefined\") {\n    this.sinon = {};\n}\n\n(function () {\n    var push = [].push;\n\n    sinon.Event = function Event(type, bubbles, cancelable, target) {\n        this.initEvent(type, bubbles, cancelable, target);\n    };\n\n    sinon.Event.prototype = {\n        initEvent: function(type, bubbles, cancelable, target) {\n            this.type = type;\n            this.bubbles = bubbles;\n            this.cancelable = cancelable;\n            this.target = target;\n        },\n\n        stopPropagation: function () {},\n\n        preventDefault: function () {\n            this.defaultPrevented = true;\n        }\n    };\n\n    sinon.ProgressEvent = function ProgressEvent(type, progressEventRaw, target) {\n        this.initEvent(type, false, false, target);\n        this.loaded = progressEventRaw.loaded || null;\n        this.total = progressEventRaw.total || null;\n    };\n\n    sinon.ProgressEvent.prototype = new sinon.Event();\n\n    sinon.ProgressEvent.prototype.constructor =  sinon.ProgressEvent;\n\n    sinon.CustomEvent = function CustomEvent(type, customData, target) {\n        this.initEvent(type, false, false, target);\n        this.detail = customData.detail || null;\n    };\n\n    sinon.CustomEvent.prototype = new sinon.Event();\n\n    sinon.CustomEvent.prototype.constructor =  sinon.CustomEvent;\n\n    sinon.EventTarget = {\n        addEventListener: function addEventListener(event, listener) {\n            this.eventListeners = this.eventListeners || {};\n            this.eventListeners[event] = this.eventListeners[event] || [];\n            push.call(this.eventListeners[event], listener);\n        },\n\n        removeEventListener: function removeEventListener(event, listener) {\n            var listeners = this.eventListeners && this.eventListeners[event] || [];\n\n            for (var i = 0, l = listeners.length; i < l; ++i) {\n                if (listeners[i] == listener) {\n                    return listeners.splice(i, 1);\n                }\n            }\n        },\n\n        dispatchEvent: function dispatchEvent(event) {\n            var type = event.type;\n            var listeners = this.eventListeners && this.eventListeners[type] || [];\n\n            for (var i = 0; i < listeners.length; i++) {\n                if (typeof listeners[i] == \"function\") {\n                    listeners[i].call(this, event);\n                } else {\n                    listeners[i].handleEvent(event);\n                }\n            }\n\n            return !!event.defaultPrevented;\n        }\n    };\n}());\n\n/**\n * @depend ../../sinon.js\n * @depend event.js\n */\n/*jslint eqeqeq: false, onevar: false*/\n/*global sinon, module, require, ActiveXObject, XMLHttpRequest, DOMParser*/\n/**\n * Fake XMLHttpRequest object\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\n// wrapper for global\n(function(global) {\n    if (typeof sinon === \"undefined\") {\n        global.sinon = {};\n    }\n\n    var supportsProgress = typeof ProgressEvent !== \"undefined\";\n    var supportsCustomEvent = typeof CustomEvent !== \"undefined\";\n    sinon.xhr = { XMLHttpRequest: global.XMLHttpRequest };\n    var xhr = sinon.xhr;\n    xhr.GlobalXMLHttpRequest = global.XMLHttpRequest;\n    xhr.GlobalActiveXObject = global.ActiveXObject;\n    xhr.supportsActiveX = typeof xhr.GlobalActiveXObject != \"undefined\";\n    xhr.supportsXHR = typeof xhr.GlobalXMLHttpRequest != \"undefined\";\n    xhr.workingXHR = xhr.supportsXHR ? xhr.GlobalXMLHttpRequest : xhr.supportsActiveX\n                                     ? function() { return new xhr.GlobalActiveXObject(\"MSXML2.XMLHTTP.3.0\") } : false;\n    xhr.supportsCORS = xhr.supportsXHR && 'withCredentials' in (new sinon.xhr.GlobalXMLHttpRequest());\n\n    /*jsl:ignore*/\n    var unsafeHeaders = {\n        \"Accept-Charset\": true,\n        \"Accept-Encoding\": true,\n        \"Connection\": true,\n        \"Content-Length\": true,\n        \"Cookie\": true,\n        \"Cookie2\": true,\n        \"Content-Transfer-Encoding\": true,\n        \"Date\": true,\n        \"Expect\": true,\n        \"Host\": true,\n        \"Keep-Alive\": true,\n        \"Referer\": true,\n        \"TE\": true,\n        \"Trailer\": true,\n        \"Transfer-Encoding\": true,\n        \"Upgrade\": true,\n        \"User-Agent\": true,\n        \"Via\": true\n    };\n    /*jsl:end*/\n\n    function FakeXMLHttpRequest() {\n        this.readyState = FakeXMLHttpRequest.UNSENT;\n        this.requestHeaders = {};\n        this.requestBody = null;\n        this.status = 0;\n        this.statusText = \"\";\n        this.upload = new UploadProgress();\n        if (sinon.xhr.supportsCORS) {\n            this.withCredentials = false;\n        }\n\n\n        var xhr = this;\n        var events = [\"loadstart\", \"load\", \"abort\", \"loadend\"];\n\n        function addEventListener(eventName) {\n            xhr.addEventListener(eventName, function (event) {\n                var listener = xhr[\"on\" + eventName];\n\n                if (listener && typeof listener == \"function\") {\n                    listener.call(this, event);\n                }\n            });\n        }\n\n        for (var i = events.length - 1; i >= 0; i--) {\n            addEventListener(events[i]);\n        }\n\n        if (typeof FakeXMLHttpRequest.onCreate == \"function\") {\n            FakeXMLHttpRequest.onCreate(this);\n        }\n    }\n\n    // An upload object is created for each\n    // FakeXMLHttpRequest and allows upload\n    // events to be simulated using uploadProgress\n    // and uploadError.\n    function UploadProgress() {\n        this.eventListeners = {\n            \"progress\": [],\n            \"load\": [],\n            \"abort\": [],\n            \"error\": []\n        }\n    }\n\n    UploadProgress.prototype.addEventListener = function(event, listener) {\n        this.eventListeners[event].push(listener);\n    };\n\n    UploadProgress.prototype.removeEventListener = function(event, listener) {\n        var listeners = this.eventListeners[event] || [];\n\n        for (var i = 0, l = listeners.length; i < l; ++i) {\n            if (listeners[i] == listener) {\n                return listeners.splice(i, 1);\n            }\n        }\n    };\n\n    UploadProgress.prototype.dispatchEvent = function(event) {\n        var listeners = this.eventListeners[event.type] || [];\n\n        for (var i = 0, listener; (listener = listeners[i]) != null; i++) {\n            listener(event);\n        }\n    };\n\n    function verifyState(xhr) {\n        if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {\n            throw new Error(\"INVALID_STATE_ERR\");\n        }\n\n        if (xhr.sendFlag) {\n            throw new Error(\"INVALID_STATE_ERR\");\n        }\n    }\n\n    // filtering to enable a white-list version of Sinon FakeXhr,\n    // where whitelisted requests are passed through to real XHR\n    function each(collection, callback) {\n        if (!collection) return;\n        for (var i = 0, l = collection.length; i < l; i += 1) {\n            callback(collection[i]);\n        }\n    }\n    function some(collection, callback) {\n        for (var index = 0; index < collection.length; index++) {\n            if(callback(collection[index]) === true) return true;\n        }\n        return false;\n    }\n    // largest arity in XHR is 5 - XHR#open\n    var apply = function(obj,method,args) {\n        switch(args.length) {\n        case 0: return obj[method]();\n        case 1: return obj[method](args[0]);\n        case 2: return obj[method](args[0],args[1]);\n        case 3: return obj[method](args[0],args[1],args[2]);\n        case 4: return obj[method](args[0],args[1],args[2],args[3]);\n        case 5: return obj[method](args[0],args[1],args[2],args[3],args[4]);\n        }\n    };\n\n    FakeXMLHttpRequest.filters = [];\n    FakeXMLHttpRequest.addFilter = function(fn) {\n        this.filters.push(fn)\n    };\n    var IE6Re = /MSIE 6/;\n    FakeXMLHttpRequest.defake = function(fakeXhr,xhrArgs) {\n        var xhr = new sinon.xhr.workingXHR();\n        each([\"open\",\"setRequestHeader\",\"send\",\"abort\",\"getResponseHeader\",\n              \"getAllResponseHeaders\",\"addEventListener\",\"overrideMimeType\",\"removeEventListener\"],\n             function(method) {\n                 fakeXhr[method] = function() {\n                   return apply(xhr,method,arguments);\n                 };\n             });\n\n        var copyAttrs = function(args) {\n            each(args, function(attr) {\n              try {\n                fakeXhr[attr] = xhr[attr]\n              } catch(e) {\n                if(!IE6Re.test(navigator.userAgent)) throw e;\n              }\n            });\n        };\n\n        var stateChange = function() {\n            fakeXhr.readyState = xhr.readyState;\n            if(xhr.readyState >= FakeXMLHttpRequest.HEADERS_RECEIVED) {\n                copyAttrs([\"status\",\"statusText\"]);\n            }\n            if(xhr.readyState >= FakeXMLHttpRequest.LOADING) {\n                copyAttrs([\"responseText\"]);\n            }\n            if(xhr.readyState === FakeXMLHttpRequest.DONE) {\n                copyAttrs([\"responseXML\"]);\n            }\n            if(fakeXhr.onreadystatechange) fakeXhr.onreadystatechange.call(fakeXhr, { target: fakeXhr });\n        };\n        if(xhr.addEventListener) {\n          for(var event in fakeXhr.eventListeners) {\n              if(fakeXhr.eventListeners.hasOwnProperty(event)) {\n                  each(fakeXhr.eventListeners[event],function(handler) {\n                      xhr.addEventListener(event, handler);\n                  });\n              }\n          }\n          xhr.addEventListener(\"readystatechange\",stateChange);\n        } else {\n          xhr.onreadystatechange = stateChange;\n        }\n        apply(xhr,\"open\",xhrArgs);\n    };\n    FakeXMLHttpRequest.useFilters = false;\n\n    function verifyRequestOpened(xhr) {\n        if (xhr.readyState != FakeXMLHttpRequest.OPENED) {\n            throw new Error(\"INVALID_STATE_ERR - \" + xhr.readyState);\n        }\n    }\n\n    function verifyRequestSent(xhr) {\n        if (xhr.readyState == FakeXMLHttpRequest.DONE) {\n            throw new Error(\"Request done\");\n        }\n    }\n\n    function verifyHeadersReceived(xhr) {\n        if (xhr.async && xhr.readyState != FakeXMLHttpRequest.HEADERS_RECEIVED) {\n            throw new Error(\"No headers received\");\n        }\n    }\n\n    function verifyResponseBodyType(body) {\n        if (typeof body != \"string\") {\n            var error = new Error(\"Attempted to respond to fake XMLHttpRequest with \" +\n                                 body + \", which is not a string.\");\n            error.name = \"InvalidBodyException\";\n            throw error;\n        }\n    }\n\n    sinon.extend(FakeXMLHttpRequest.prototype, sinon.EventTarget, {\n        async: true,\n\n        open: function open(method, url, async, username, password) {\n            this.method = method;\n            this.url = url;\n            this.async = typeof async == \"boolean\" ? async : true;\n            this.username = username;\n            this.password = password;\n            this.responseText = null;\n            this.responseXML = null;\n            this.requestHeaders = {};\n            this.sendFlag = false;\n            if(sinon.FakeXMLHttpRequest.useFilters === true) {\n                var xhrArgs = arguments;\n                var defake = some(FakeXMLHttpRequest.filters,function(filter) {\n                    return filter.apply(this,xhrArgs)\n                });\n                if (defake) {\n                  return sinon.FakeXMLHttpRequest.defake(this,arguments);\n                }\n            }\n            this.readyStateChange(FakeXMLHttpRequest.OPENED);\n        },\n\n        readyStateChange: function readyStateChange(state) {\n            this.readyState = state;\n\n            if (typeof this.onreadystatechange == \"function\") {\n                try {\n                    this.onreadystatechange();\n                } catch (e) {\n                    sinon.logError(\"Fake XHR onreadystatechange handler\", e);\n                }\n            }\n\n            this.dispatchEvent(new sinon.Event(\"readystatechange\"));\n\n            switch (this.readyState) {\n                case FakeXMLHttpRequest.DONE:\n                    this.dispatchEvent(new sinon.Event(\"load\", false, false, this));\n                    this.dispatchEvent(new sinon.Event(\"loadend\", false, false, this));\n                    this.upload.dispatchEvent(new sinon.Event(\"load\", false, false, this));\n                    if (supportsProgress) {\n                        this.upload.dispatchEvent(new sinon.ProgressEvent('progress', {loaded: 100, total: 100}));\n                    }\n                    break;\n            }\n        },\n\n        setRequestHeader: function setRequestHeader(header, value) {\n            verifyState(this);\n\n            if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) {\n                throw new Error(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\n            }\n\n            if (this.requestHeaders[header]) {\n                this.requestHeaders[header] += \",\" + value;\n            } else {\n                this.requestHeaders[header] = value;\n            }\n        },\n\n        // Helps testing\n        setResponseHeaders: function setResponseHeaders(headers) {\n            verifyRequestOpened(this);\n            this.responseHeaders = {};\n\n            for (var header in headers) {\n                if (headers.hasOwnProperty(header)) {\n                    this.responseHeaders[header] = headers[header];\n                }\n            }\n\n            if (this.async) {\n                this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);\n            } else {\n                this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;\n            }\n        },\n\n        // Currently treats ALL data as a DOMString (i.e. no Document)\n        send: function send(data) {\n            verifyState(this);\n\n            if (!/^(get|head)$/i.test(this.method)) {\n                if (this.requestHeaders[\"Content-Type\"]) {\n                    var value = this.requestHeaders[\"Content-Type\"].split(\";\");\n                    this.requestHeaders[\"Content-Type\"] = value[0] + \";charset=utf-8\";\n                } else {\n                    this.requestHeaders[\"Content-Type\"] = \"text/plain;charset=utf-8\";\n                }\n\n                this.requestBody = data;\n            }\n\n            this.errorFlag = false;\n            this.sendFlag = this.async;\n            this.readyStateChange(FakeXMLHttpRequest.OPENED);\n\n            if (typeof this.onSend == \"function\") {\n                this.onSend(this);\n            }\n\n            this.dispatchEvent(new sinon.Event(\"loadstart\", false, false, this));\n        },\n\n        abort: function abort() {\n            this.aborted = true;\n            this.responseText = null;\n            this.errorFlag = true;\n            this.requestHeaders = {};\n\n            if (this.readyState > sinon.FakeXMLHttpRequest.UNSENT && this.sendFlag) {\n                this.readyStateChange(sinon.FakeXMLHttpRequest.DONE);\n                this.sendFlag = false;\n            }\n\n            this.readyState = sinon.FakeXMLHttpRequest.UNSENT;\n\n            this.dispatchEvent(new sinon.Event(\"abort\", false, false, this));\n\n            this.upload.dispatchEvent(new sinon.Event(\"abort\", false, false, this));\n\n            if (typeof this.onerror === \"function\") {\n                this.onerror();\n            }\n        },\n\n        getResponseHeader: function getResponseHeader(header) {\n            if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n                return null;\n            }\n\n            if (/^Set-Cookie2?$/i.test(header)) {\n                return null;\n            }\n\n            header = header.toLowerCase();\n\n            for (var h in this.responseHeaders) {\n                if (h.toLowerCase() == header) {\n                    return this.responseHeaders[h];\n                }\n            }\n\n            return null;\n        },\n\n        getAllResponseHeaders: function getAllResponseHeaders() {\n            if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n                return \"\";\n            }\n\n            var headers = \"\";\n\n            for (var header in this.responseHeaders) {\n                if (this.responseHeaders.hasOwnProperty(header) &&\n                    !/^Set-Cookie2?$/i.test(header)) {\n                    headers += header + \": \" + this.responseHeaders[header] + \"\\r\\n\";\n                }\n            }\n\n            return headers;\n        },\n\n        setResponseBody: function setResponseBody(body) {\n            verifyRequestSent(this);\n            verifyHeadersReceived(this);\n            verifyResponseBodyType(body);\n\n            var chunkSize = this.chunkSize || 10;\n            var index = 0;\n            this.responseText = \"\";\n\n            do {\n                if (this.async) {\n                    this.readyStateChange(FakeXMLHttpRequest.LOADING);\n                }\n\n                this.responseText += body.substring(index, index + chunkSize);\n                index += chunkSize;\n            } while (index < body.length);\n\n            var type = this.getResponseHeader(\"Content-Type\");\n\n            if (this.responseText &&\n                (!type || /(text\\/xml)|(application\\/xml)|(\\+xml)/.test(type))) {\n                try {\n                    this.responseXML = FakeXMLHttpRequest.parseXML(this.responseText);\n                } catch (e) {\n                    // Unable to parse XML - no biggie\n                }\n            }\n\n            if (this.async) {\n                this.readyStateChange(FakeXMLHttpRequest.DONE);\n            } else {\n                this.readyState = FakeXMLHttpRequest.DONE;\n            }\n        },\n\n        respond: function respond(status, headers, body) {\n            this.status = typeof status == \"number\" ? status : 200;\n            this.statusText = FakeXMLHttpRequest.statusCodes[this.status];\n            this.setResponseHeaders(headers || {});\n            this.setResponseBody(body || \"\");\n        },\n\n        uploadProgress: function uploadProgress(progressEventRaw) {\n            if (supportsProgress) {\n                this.upload.dispatchEvent(new sinon.ProgressEvent(\"progress\", progressEventRaw));\n            }\n        },\n\n        uploadError: function uploadError(error) {\n            if (supportsCustomEvent) {\n                this.upload.dispatchEvent(new sinon.CustomEvent(\"error\", {\"detail\": error}));\n            }\n        }\n    });\n\n    sinon.extend(FakeXMLHttpRequest, {\n        UNSENT: 0,\n        OPENED: 1,\n        HEADERS_RECEIVED: 2,\n        LOADING: 3,\n        DONE: 4\n    });\n\n    // Borrowed from JSpec\n    FakeXMLHttpRequest.parseXML = function parseXML(text) {\n        var xmlDoc;\n\n        if (typeof DOMParser != \"undefined\") {\n            var parser = new DOMParser();\n            xmlDoc = parser.parseFromString(text, \"text/xml\");\n        } else {\n            xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n            xmlDoc.async = \"false\";\n            xmlDoc.loadXML(text);\n        }\n\n        return xmlDoc;\n    };\n\n    FakeXMLHttpRequest.statusCodes = {\n        100: \"Continue\",\n        101: \"Switching Protocols\",\n        200: \"OK\",\n        201: \"Created\",\n        202: \"Accepted\",\n        203: \"Non-Authoritative Information\",\n        204: \"No Content\",\n        205: \"Reset Content\",\n        206: \"Partial Content\",\n        300: \"Multiple Choice\",\n        301: \"Moved Permanently\",\n        302: \"Found\",\n        303: \"See Other\",\n        304: \"Not Modified\",\n        305: \"Use Proxy\",\n        307: \"Temporary Redirect\",\n        400: \"Bad Request\",\n        401: \"Unauthorized\",\n        402: \"Payment Required\",\n        403: \"Forbidden\",\n        404: \"Not Found\",\n        405: \"Method Not Allowed\",\n        406: \"Not Acceptable\",\n        407: \"Proxy Authentication Required\",\n        408: \"Request Timeout\",\n        409: \"Conflict\",\n        410: \"Gone\",\n        411: \"Length Required\",\n        412: \"Precondition Failed\",\n        413: \"Request Entity Too Large\",\n        414: \"Request-URI Too Long\",\n        415: \"Unsupported Media Type\",\n        416: \"Requested Range Not Satisfiable\",\n        417: \"Expectation Failed\",\n        422: \"Unprocessable Entity\",\n        500: \"Internal Server Error\",\n        501: \"Not Implemented\",\n        502: \"Bad Gateway\",\n        503: \"Service Unavailable\",\n        504: \"Gateway Timeout\",\n        505: \"HTTP Version Not Supported\"\n    };\n\n    sinon.useFakeXMLHttpRequest = function () {\n        sinon.FakeXMLHttpRequest.restore = function restore(keepOnCreate) {\n            if (xhr.supportsXHR) {\n                global.XMLHttpRequest = xhr.GlobalXMLHttpRequest;\n            }\n\n            if (xhr.supportsActiveX) {\n                global.ActiveXObject = xhr.GlobalActiveXObject;\n            }\n\n            delete sinon.FakeXMLHttpRequest.restore;\n\n            if (keepOnCreate !== true) {\n                delete sinon.FakeXMLHttpRequest.onCreate;\n            }\n        };\n        if (xhr.supportsXHR) {\n            global.XMLHttpRequest = sinon.FakeXMLHttpRequest;\n        }\n\n        if (xhr.supportsActiveX) {\n            global.ActiveXObject = function ActiveXObject(objId) {\n                if (objId == \"Microsoft.XMLHTTP\" || /^Msxml2\\.XMLHTTP/i.test(objId)) {\n\n                    return new sinon.FakeXMLHttpRequest();\n                }\n\n                return new xhr.GlobalActiveXObject(objId);\n            };\n        }\n\n        return sinon.FakeXMLHttpRequest;\n    };\n\n    sinon.FakeXMLHttpRequest = FakeXMLHttpRequest;\n\n})((function(){ return typeof global === \"object\" ? global : this; })());\n\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = sinon;\n}\n\n/**\n * @depend fake_xml_http_request.js\n */\n/*jslint eqeqeq: false, onevar: false, regexp: false, plusplus: false*/\n/*global module, require, window*/\n/**\n * The Sinon \"server\" mimics a web server that receives requests from\n * sinon.FakeXMLHttpRequest and provides an API to respond to those requests,\n * both synchronously and asynchronously. To respond synchronuously, canned\n * answers have to be provided upfront.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\nif (typeof sinon == \"undefined\") {\n    var sinon = {};\n}\n\nsinon.fakeServer = (function () {\n    var push = [].push;\n    function F() {}\n\n    function create(proto) {\n        F.prototype = proto;\n        return new F();\n    }\n\n    function responseArray(handler) {\n        var response = handler;\n\n        if (Object.prototype.toString.call(handler) != \"[object Array]\") {\n            response = [200, {}, handler];\n        }\n\n        if (typeof response[2] != \"string\") {\n            throw new TypeError(\"Fake server response body should be string, but was \" +\n                                typeof response[2]);\n        }\n\n        return response;\n    }\n\n    var wloc = typeof window !== \"undefined\" ? window.location : {};\n    var rCurrLoc = new RegExp(\"^\" + wloc.protocol + \"//\" + wloc.host);\n\n    function matchOne(response, reqMethod, reqUrl) {\n        var rmeth = response.method;\n        var matchMethod = !rmeth || rmeth.toLowerCase() == reqMethod.toLowerCase();\n        var url = response.url;\n        var matchUrl = !url || url == reqUrl || (typeof url.test == \"function\" && url.test(reqUrl));\n\n        return matchMethod && matchUrl;\n    }\n\n    function match(response, request) {\n        var requestUrl = request.url;\n\n        if (!/^https?:\\/\\//.test(requestUrl) || rCurrLoc.test(requestUrl)) {\n            requestUrl = requestUrl.replace(rCurrLoc, \"\");\n        }\n\n        if (matchOne(response, this.getHTTPMethod(request), requestUrl)) {\n            if (typeof response.response == \"function\") {\n                var ru = response.url;\n                var args = [request].concat(ru && typeof ru.exec == \"function\" ? ru.exec(requestUrl).slice(1) : []);\n                return response.response.apply(response, args);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    return {\n        create: function () {\n            var server = create(this);\n            this.xhr = sinon.useFakeXMLHttpRequest();\n            server.requests = [];\n\n            this.xhr.onCreate = function (xhrObj) {\n                server.addRequest(xhrObj);\n            };\n\n            return server;\n        },\n\n        addRequest: function addRequest(xhrObj) {\n            var server = this;\n            push.call(this.requests, xhrObj);\n\n            xhrObj.onSend = function () {\n                server.handleRequest(this);\n\n                if (server.autoRespond && !server.responding) {\n                    setTimeout(function () {\n                        server.responding = false;\n                        server.respond();\n                    }, server.autoRespondAfter || 10);\n\n                    server.responding = true;\n                }\n            };\n        },\n\n        getHTTPMethod: function getHTTPMethod(request) {\n            if (this.fakeHTTPMethods && /post/i.test(request.method)) {\n                var matches = (request.requestBody || \"\").match(/_method=([^\\b;]+)/);\n                return !!matches ? matches[1] : request.method;\n            }\n\n            return request.method;\n        },\n\n        handleRequest: function handleRequest(xhr) {\n            if (xhr.async) {\n                if (!this.queue) {\n                    this.queue = [];\n                }\n\n                push.call(this.queue, xhr);\n            } else {\n                this.processRequest(xhr);\n            }\n        },\n\n        log: function(response, request) {\n            var str;\n\n            str =  \"Request:\\n\"  + sinon.format(request)  + \"\\n\\n\";\n            str += \"Response:\\n\" + sinon.format(response) + \"\\n\\n\";\n\n            sinon.log(str);\n        },\n\n        respondWith: function respondWith(method, url, body) {\n            if (arguments.length == 1 && typeof method != \"function\") {\n                this.response = responseArray(method);\n                return;\n            }\n\n            if (!this.responses) { this.responses = []; }\n\n            if (arguments.length == 1) {\n                body = method;\n                url = method = null;\n            }\n\n            if (arguments.length == 2) {\n                body = url;\n                url = method;\n                method = null;\n            }\n\n            push.call(this.responses, {\n                method: method,\n                url: url,\n                response: typeof body == \"function\" ? body : responseArray(body)\n            });\n        },\n\n        respond: function respond() {\n            if (arguments.length > 0) this.respondWith.apply(this, arguments);\n            var queue = this.queue || [];\n            var requests = queue.splice(0, queue.length);\n            var request;\n\n            while(request = requests.shift()) {\n                this.processRequest(request);\n            }\n        },\n\n        processRequest: function processRequest(request) {\n            try {\n                if (request.aborted) {\n                    return;\n                }\n\n                var response = this.response || [404, {}, \"\"];\n\n                if (this.responses) {\n                    for (var l = this.responses.length, i = l - 1; i >= 0; i--) {\n                        if (match.call(this, this.responses[i], request)) {\n                            response = this.responses[i].response;\n                            break;\n                        }\n                    }\n                }\n\n                if (request.readyState != 4) {\n                    sinon.fakeServer.log(response, request);\n\n                    request.respond(response[0], response[1], response[2]);\n                }\n            } catch (e) {\n                sinon.logError(\"Fake server request processing\", e);\n            }\n        },\n\n        restore: function restore() {\n            return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);\n        }\n    };\n}());\n\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = sinon;\n}\n\n/**\n * @depend fake_server.js\n * @depend fake_timers.js\n */\n/*jslint browser: true, eqeqeq: false, onevar: false*/\n/*global sinon*/\n/**\n * Add-on for sinon.fakeServer that automatically handles a fake timer along with\n * the FakeXMLHttpRequest. The direct inspiration for this add-on is jQuery\n * 1.3.x, which does not use xhr object's onreadystatehandler at all - instead,\n * it polls the object for completion with setInterval. Dispite the direct\n * motivation, there is nothing jQuery-specific in this file, so it can be used\n * in any environment where the ajax implementation depends on setInterval or\n * setTimeout.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\n(function () {\n    function Server() {}\n    Server.prototype = sinon.fakeServer;\n\n    sinon.fakeServerWithClock = new Server();\n\n    sinon.fakeServerWithClock.addRequest = function addRequest(xhr) {\n        if (xhr.async) {\n            if (typeof setTimeout.clock == \"object\") {\n                this.clock = setTimeout.clock;\n            } else {\n                this.clock = sinon.useFakeTimers();\n                this.resetClock = true;\n            }\n\n            if (!this.longestTimeout) {\n                var clockSetTimeout = this.clock.setTimeout;\n                var clockSetInterval = this.clock.setInterval;\n                var server = this;\n\n                this.clock.setTimeout = function (fn, timeout) {\n                    server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\n\n                    return clockSetTimeout.apply(this, arguments);\n                };\n\n                this.clock.setInterval = function (fn, timeout) {\n                    server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\n\n                    return clockSetInterval.apply(this, arguments);\n                };\n            }\n        }\n\n        return sinon.fakeServer.addRequest.call(this, xhr);\n    };\n\n    sinon.fakeServerWithClock.respond = function respond() {\n        var returnVal = sinon.fakeServer.respond.apply(this, arguments);\n\n        if (this.clock) {\n            this.clock.tick(this.longestTimeout || 0);\n            this.longestTimeout = 0;\n\n            if (this.resetClock) {\n                this.clock.restore();\n                this.resetClock = false;\n            }\n        }\n\n        return returnVal;\n    };\n\n    sinon.fakeServerWithClock.restore = function restore() {\n        if (this.clock) {\n            this.clock.restore();\n        }\n\n        return sinon.fakeServer.restore.apply(this, arguments);\n    };\n}());\n\n/**\n * @depend ../sinon.js\n * @depend collection.js\n * @depend util/fake_timers.js\n * @depend util/fake_server_with_clock.js\n */\n/*jslint eqeqeq: false, onevar: false, plusplus: false*/\n/*global require, module*/\n/**\n * Manages fake collections as well as fake utilities such as Sinon's\n * timers and fake XHR implementation in one convenient object.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\nif (typeof module !== \"undefined\" && module.exports && typeof require == \"function\") {\n    var sinon = require(\"../sinon\");\n    sinon.extend(sinon, require(\"./util/fake_timers\"));\n}\n\n(function () {\n    var push = [].push;\n\n    function exposeValue(sandbox, config, key, value) {\n        if (!value) {\n            return;\n        }\n\n        if (config.injectInto && !(key in config.injectInto)) {\n            config.injectInto[key] = value;\n            sandbox.injectedKeys.push(key);\n        } else {\n            push.call(sandbox.args, value);\n        }\n    }\n\n    function prepareSandboxFromConfig(config) {\n        var sandbox = sinon.create(sinon.sandbox);\n\n        if (config.useFakeServer) {\n            if (typeof config.useFakeServer == \"object\") {\n                sandbox.serverPrototype = config.useFakeServer;\n            }\n\n            sandbox.useFakeServer();\n        }\n\n        if (config.useFakeTimers) {\n            if (typeof config.useFakeTimers == \"object\") {\n                sandbox.useFakeTimers.apply(sandbox, config.useFakeTimers);\n            } else {\n                sandbox.useFakeTimers();\n            }\n        }\n\n        return sandbox;\n    }\n\n    sinon.sandbox = sinon.extend(sinon.create(sinon.collection), {\n        useFakeTimers: function useFakeTimers() {\n            this.clock = sinon.useFakeTimers.apply(sinon, arguments);\n\n            return this.add(this.clock);\n        },\n\n        serverPrototype: sinon.fakeServer,\n\n        useFakeServer: function useFakeServer() {\n            var proto = this.serverPrototype || sinon.fakeServer;\n\n            if (!proto || !proto.create) {\n                return null;\n            }\n\n            this.server = proto.create();\n            return this.add(this.server);\n        },\n\n        inject: function (obj) {\n            sinon.collection.inject.call(this, obj);\n\n            if (this.clock) {\n                obj.clock = this.clock;\n            }\n\n            if (this.server) {\n                obj.server = this.server;\n                obj.requests = this.server.requests;\n            }\n\n            return obj;\n        },\n\n        restore: function () {\n            sinon.collection.restore.apply(this, arguments);\n            this.restoreContext();\n        },\n\n        restoreContext: function () {\n            if (this.injectedKeys) {\n                for (var i = 0, j = this.injectedKeys.length; i < j; i++) {\n                    delete this.injectInto[this.injectedKeys[i]];\n                }\n                this.injectedKeys = [];\n            }\n        },\n\n        create: function (config) {\n            if (!config) {\n                return sinon.create(sinon.sandbox);\n            }\n\n            var sandbox = prepareSandboxFromConfig(config);\n            sandbox.args = sandbox.args || [];\n            sandbox.injectedKeys = [];\n            sandbox.injectInto = config.injectInto;\n            var prop, value, exposed = sandbox.inject({});\n\n            if (config.properties) {\n                for (var i = 0, l = config.properties.length; i < l; i++) {\n                    prop = config.properties[i];\n                    value = exposed[prop] || prop == \"sandbox\" && sandbox;\n                    exposeValue(sandbox, config, prop, value);\n                }\n            } else {\n                exposeValue(sandbox, config, \"sandbox\", value);\n            }\n\n            return sandbox;\n        }\n    });\n\n    sinon.sandbox.useFakeXMLHttpRequest = sinon.sandbox.useFakeServer;\n\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], function(module) { module.exports = sinon.sandbox; });\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = sinon.sandbox;\n    }\n}());\n\n/**\n * @depend ../sinon.js\n * @depend stub.js\n * @depend mock.js\n * @depend sandbox.js\n */\n/*jslint eqeqeq: false, onevar: false, forin: true, plusplus: false*/\n/*global module, require, sinon*/\n/**\n * Test function, sandboxes fakes\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module !== \"undefined\" && module.exports && typeof require == \"function\";\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function test(callback) {\n        var type = typeof callback;\n\n        if (type != \"function\") {\n            throw new TypeError(\"sinon.test needs to wrap a test function, got \" + type);\n        }\n\n        function sinonSandboxedTest() {\n            var config = sinon.getConfig(sinon.config);\n            config.injectInto = config.injectIntoThis && this || config.injectInto;\n            var sandbox = sinon.sandbox.create(config);\n            var exception, result;\n            var args = Array.prototype.slice.call(arguments).concat(sandbox.args);\n\n            try {\n                result = callback.apply(this, args);\n            } catch (e) {\n                exception = e;\n            }\n\n            if (typeof exception !== \"undefined\") {\n                sandbox.restore();\n                throw exception;\n            }\n            else {\n                sandbox.verifyAndRestore();\n            }\n\n            return result;\n        };\n\n        if (callback.length) {\n            return function sinonAsyncSandboxedTest(callback) {\n                return sinonSandboxedTest.apply(this, arguments);\n            };\n        }\n\n        return sinonSandboxedTest;\n    }\n\n    test.config = {\n        injectIntoThis: true,\n        injectInto: null,\n        properties: [\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"],\n        useFakeTimers: true,\n        useFakeServer: true\n    };\n\n    sinon.test = test;\n\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], function(module) { module.exports = test; });\n    } else if (commonJSModule) {\n        module.exports = test;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n * @depend ../sinon.js\n * @depend test.js\n */\n/*jslint eqeqeq: false, onevar: false, eqeqeq: false*/\n/*global module, require, sinon*/\n/**\n * Test case, sandboxes all test functions\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module !== \"undefined\" && module.exports && typeof require == \"function\";\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon || !Object.prototype.hasOwnProperty) {\n        return;\n    }\n\n    function createTest(property, setUp, tearDown) {\n        return function () {\n            if (setUp) {\n                setUp.apply(this, arguments);\n            }\n\n            var exception, result;\n\n            try {\n                result = property.apply(this, arguments);\n            } catch (e) {\n                exception = e;\n            }\n\n            if (tearDown) {\n                tearDown.apply(this, arguments);\n            }\n\n            if (exception) {\n                throw exception;\n            }\n\n            return result;\n        };\n    }\n\n    function testCase(tests, prefix) {\n        /*jsl:ignore*/\n        if (!tests || typeof tests != \"object\") {\n            throw new TypeError(\"sinon.testCase needs an object with test functions\");\n        }\n        /*jsl:end*/\n\n        prefix = prefix || \"test\";\n        var rPrefix = new RegExp(\"^\" + prefix);\n        var methods = {}, testName, property, method;\n        var setUp = tests.setUp;\n        var tearDown = tests.tearDown;\n\n        for (testName in tests) {\n            if (tests.hasOwnProperty(testName)) {\n                property = tests[testName];\n\n                if (/^(setUp|tearDown)$/.test(testName)) {\n                    continue;\n                }\n\n                if (typeof property == \"function\" && rPrefix.test(testName)) {\n                    method = property;\n\n                    if (setUp || tearDown) {\n                        method = createTest(property, setUp, tearDown);\n                    }\n\n                    methods[testName] = sinon.test(method);\n                } else {\n                    methods[testName] = tests[testName];\n                }\n            }\n        }\n\n        return methods;\n    }\n\n    sinon.testCase = testCase;\n\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], function(module) { module.exports = testCase; });\n    } else if (commonJSModule) {\n        module.exports = testCase;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n * @depend ../sinon.js\n * @depend stub.js\n */\n/*jslint eqeqeq: false, onevar: false, nomen: false, plusplus: false*/\n/*global module, require, sinon*/\n/**\n * Assertions matching the test spy retrieval interface.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n\n(function (sinon, global) {\n    var commonJSModule = typeof module !== \"undefined\" && module.exports && typeof require == \"function\";\n    var slice = Array.prototype.slice;\n    var assert;\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function verifyIsStub() {\n        var method;\n\n        for (var i = 0, l = arguments.length; i < l; ++i) {\n            method = arguments[i];\n\n            if (!method) {\n                assert.fail(\"fake is not a spy\");\n            }\n\n            if (typeof method != \"function\") {\n                assert.fail(method + \" is not a function\");\n            }\n\n            if (typeof method.getCall != \"function\") {\n                assert.fail(method + \" is not stubbed\");\n            }\n        }\n    }\n\n    function failAssertion(object, msg) {\n        object = object || global;\n        var failMethod = object.fail || assert.fail;\n        failMethod.call(object, msg);\n    }\n\n    function mirrorPropAsAssertion(name, method, message) {\n        if (arguments.length == 2) {\n            message = method;\n            method = name;\n        }\n\n        assert[name] = function (fake) {\n            verifyIsStub(fake);\n\n            var args = slice.call(arguments, 1);\n            var failed = false;\n\n            if (typeof method == \"function\") {\n                failed = !method(fake);\n            } else {\n                failed = typeof fake[method] == \"function\" ?\n                    !fake[method].apply(fake, args) : !fake[method];\n            }\n\n            if (failed) {\n                failAssertion(this, fake.printf.apply(fake, [message].concat(args)));\n            } else {\n                assert.pass(name);\n            }\n        };\n    }\n\n    function exposedName(prefix, prop) {\n        return !prefix || /^fail/.test(prop) ? prop :\n            prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);\n    }\n\n    assert = {\n        failException: \"AssertError\",\n\n        fail: function fail(message) {\n            var error = new Error(message);\n            error.name = this.failException || assert.failException;\n\n            throw error;\n        },\n\n        pass: function pass(assertion) {},\n\n        callOrder: function assertCallOrder() {\n            verifyIsStub.apply(null, arguments);\n            var expected = \"\", actual = \"\";\n\n            if (!sinon.calledInOrder(arguments)) {\n                try {\n                    expected = [].join.call(arguments, \", \");\n                    var calls = slice.call(arguments);\n                    var i = calls.length;\n                    while (i) {\n                        if (!calls[--i].called) {\n                            calls.splice(i, 1);\n                        }\n                    }\n                    actual = sinon.orderByFirstCall(calls).join(\", \");\n                } catch (e) {\n                    // If this fails, we'll just fall back to the blank string\n                }\n\n                failAssertion(this, \"expected \" + expected + \" to be \" +\n                              \"called in order but were called as \" + actual);\n            } else {\n                assert.pass(\"callOrder\");\n            }\n        },\n\n        callCount: function assertCallCount(method, count) {\n            verifyIsStub(method);\n\n            if (method.callCount != count) {\n                var msg = \"expected %n to be called \" + sinon.timesInWords(count) +\n                    \" but was called %c%C\";\n                failAssertion(this, method.printf(msg));\n            } else {\n                assert.pass(\"callCount\");\n            }\n        },\n\n        expose: function expose(target, options) {\n            if (!target) {\n                throw new TypeError(\"target is null or undefined\");\n            }\n\n            var o = options || {};\n            var prefix = typeof o.prefix == \"undefined\" && \"assert\" || o.prefix;\n            var includeFail = typeof o.includeFail == \"undefined\" || !!o.includeFail;\n\n            for (var method in this) {\n                if (method != \"export\" && (includeFail || !/^(fail)/.test(method))) {\n                    target[exposedName(prefix, method)] = this[method];\n                }\n            }\n\n            return target;\n        },\n\n        match: function match(actual, expectation) {\n            var matcher = sinon.match(expectation);\n            if (matcher.test(actual)) {\n                assert.pass(\"match\");\n            } else {\n                var formatted = [\n                    \"expected value to match\",\n                    \"    expected = \" + sinon.format(expectation),\n                    \"    actual = \" + sinon.format(actual)\n                ]\n                failAssertion(this, formatted.join(\"\\n\"));\n            }\n        }\n    };\n\n    mirrorPropAsAssertion(\"called\", \"expected %n to have been called at least once but was never called\");\n    mirrorPropAsAssertion(\"notCalled\", function (spy) { return !spy.called; },\n                          \"expected %n to not have been called but was called %c%C\");\n    mirrorPropAsAssertion(\"calledOnce\", \"expected %n to be called once but was called %c%C\");\n    mirrorPropAsAssertion(\"calledTwice\", \"expected %n to be called twice but was called %c%C\");\n    mirrorPropAsAssertion(\"calledThrice\", \"expected %n to be called thrice but was called %c%C\");\n    mirrorPropAsAssertion(\"calledOn\", \"expected %n to be called with %1 as this but was called with %t\");\n    mirrorPropAsAssertion(\"alwaysCalledOn\", \"expected %n to always be called with %1 as this but was called with %t\");\n    mirrorPropAsAssertion(\"calledWithNew\", \"expected %n to be called with new\");\n    mirrorPropAsAssertion(\"alwaysCalledWithNew\", \"expected %n to always be called with new\");\n    mirrorPropAsAssertion(\"calledWith\", \"expected %n to be called with arguments %*%C\");\n    mirrorPropAsAssertion(\"calledWithMatch\", \"expected %n to be called with match %*%C\");\n    mirrorPropAsAssertion(\"alwaysCalledWith\", \"expected %n to always be called with arguments %*%C\");\n    mirrorPropAsAssertion(\"alwaysCalledWithMatch\", \"expected %n to always be called with match %*%C\");\n    mirrorPropAsAssertion(\"calledWithExactly\", \"expected %n to be called with exact arguments %*%C\");\n    mirrorPropAsAssertion(\"alwaysCalledWithExactly\", \"expected %n to always be called with exact arguments %*%C\");\n    mirrorPropAsAssertion(\"neverCalledWith\", \"expected %n to never be called with arguments %*%C\");\n    mirrorPropAsAssertion(\"neverCalledWithMatch\", \"expected %n to never be called with match %*%C\");\n    mirrorPropAsAssertion(\"threw\", \"%n did not throw exception%C\");\n    mirrorPropAsAssertion(\"alwaysThrew\", \"%n did not always throw exception%C\");\n\n    sinon.assert = assert;\n\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], function(module) { module.exports = assert; });\n    } else if (commonJSModule) {\n        module.exports = assert;\n    }\n}(typeof sinon == \"object\" && sinon || null, typeof window != \"undefined\" ? window : (typeof self != \"undefined\") ? self : global));\n\n/**\n * @depend ../../sinon.js\n * @depend event.js\n */\n/*jslint eqeqeq: false, onevar: false*/\n/*global sinon, module, require, XDomainRequest*/\n/**\n * Fake XDomainRequest object\n */\n\nif (typeof sinon == \"undefined\") {\n    this.sinon = {};\n}\nsinon.xdr = { XDomainRequest: this.XDomainRequest };\n\n// wrapper for global\n(function (global) {\n    var xdr = sinon.xdr;\n    xdr.GlobalXDomainRequest = global.XDomainRequest;\n    xdr.supportsXDR = typeof xdr.GlobalXDomainRequest != \"undefined\";\n    xdr.workingXDR = xdr.supportsXDR ? xdr.GlobalXDomainRequest :  false;\n\n    function FakeXDomainRequest() {\n        this.readyState = FakeXDomainRequest.UNSENT;\n        this.requestBody = null;\n        this.requestHeaders = {};\n        this.status = 0;\n        this.timeout = null;\n\n        if (typeof FakeXDomainRequest.onCreate == \"function\") {\n            FakeXDomainRequest.onCreate(this);\n        }\n    }\n\n    function verifyState(xdr) {\n        if (xdr.readyState !== FakeXDomainRequest.OPENED) {\n            throw new Error(\"INVALID_STATE_ERR\");\n        }\n\n        if (xdr.sendFlag) {\n            throw new Error(\"INVALID_STATE_ERR\");\n        }\n    }\n\n    function verifyRequestSent(xdr) {\n        if (xdr.readyState == FakeXDomainRequest.UNSENT) {\n            throw new Error(\"Request not sent\");\n        }\n        if (xdr.readyState == FakeXDomainRequest.DONE) {\n            throw new Error(\"Request done\");\n        }\n    }\n\n    function verifyResponseBodyType(body) {\n        if (typeof body != \"string\") {\n            var error = new Error(\"Attempted to respond to fake XDomainRequest with \" +\n                                  body + \", which is not a string.\");\n            error.name = \"InvalidBodyException\";\n            throw error;\n        }\n    }\n\n    sinon.extend(FakeXDomainRequest.prototype, sinon.EventTarget, {\n        open: function open(method, url) {\n            this.method = method;\n            this.url = url;\n\n            this.responseText = null;\n            this.sendFlag = false;\n\n            this.readyStateChange(FakeXDomainRequest.OPENED);\n        },\n\n        readyStateChange: function readyStateChange(state) {\n            this.readyState = state;\n            var eventName = '';\n            switch (this.readyState) {\n            case FakeXDomainRequest.UNSENT:\n                break;\n            case FakeXDomainRequest.OPENED:\n                break;\n            case FakeXDomainRequest.LOADING:\n                if (this.sendFlag){\n                    //raise the progress event\n                    eventName = 'onprogress';\n                }\n                break;\n            case FakeXDomainRequest.DONE:\n                if (this.isTimeout){\n                    eventName = 'ontimeout'\n                }\n                else if (this.errorFlag || (this.status < 200 || this.status > 299)) {\n                    eventName = 'onerror';\n                }\n                else {\n                    eventName = 'onload'\n                }\n                break;\n            }\n\n            // raising event (if defined)\n            if (eventName) {\n                if (typeof this[eventName] == \"function\") {\n                    try {\n                        this[eventName]();\n                    } catch (e) {\n                        sinon.logError(\"Fake XHR \" + eventName + \" handler\", e);\n                    }\n                }\n            }\n        },\n\n        send: function send(data) {\n            verifyState(this);\n\n            if (!/^(get|head)$/i.test(this.method)) {\n                this.requestBody = data;\n            }\n            this.requestHeaders[\"Content-Type\"] = \"text/plain;charset=utf-8\";\n\n            this.errorFlag = false;\n            this.sendFlag = true;\n            this.readyStateChange(FakeXDomainRequest.OPENED);\n\n            if (typeof this.onSend == \"function\") {\n                this.onSend(this);\n            }\n        },\n\n        abort: function abort() {\n            this.aborted = true;\n            this.responseText = null;\n            this.errorFlag = true;\n\n            if (this.readyState > sinon.FakeXDomainRequest.UNSENT && this.sendFlag) {\n                this.readyStateChange(sinon.FakeXDomainRequest.DONE);\n                this.sendFlag = false;\n            }\n        },\n\n        setResponseBody: function setResponseBody(body) {\n            verifyRequestSent(this);\n            verifyResponseBodyType(body);\n\n            var chunkSize = this.chunkSize || 10;\n            var index = 0;\n            this.responseText = \"\";\n\n            do {\n                this.readyStateChange(FakeXDomainRequest.LOADING);\n                this.responseText += body.substring(index, index + chunkSize);\n                index += chunkSize;\n            } while (index < body.length);\n\n            this.readyStateChange(FakeXDomainRequest.DONE);\n        },\n\n        respond: function respond(status, contentType, body) {\n            // content-type ignored, since XDomainRequest does not carry this\n            // we keep the same syntax for respond(...) as for FakeXMLHttpRequest to ease\n            // test integration across browsers\n            this.status = typeof status == \"number\" ? status : 200;\n            this.setResponseBody(body || \"\");\n        },\n\n        simulatetimeout: function(){\n            this.status = 0;\n            this.isTimeout = true;\n            // Access to this should actually throw an error\n            this.responseText = undefined;\n            this.readyStateChange(FakeXDomainRequest.DONE);\n        }\n    });\n\n    sinon.extend(FakeXDomainRequest, {\n        UNSENT: 0,\n        OPENED: 1,\n        LOADING: 3,\n        DONE: 4\n    });\n\n    sinon.useFakeXDomainRequest = function () {\n        sinon.FakeXDomainRequest.restore = function restore(keepOnCreate) {\n            if (xdr.supportsXDR) {\n                global.XDomainRequest = xdr.GlobalXDomainRequest;\n            }\n\n            delete sinon.FakeXDomainRequest.restore;\n\n            if (keepOnCreate !== true) {\n                delete sinon.FakeXDomainRequest.onCreate;\n            }\n        };\n        if (xdr.supportsXDR) {\n            global.XDomainRequest = sinon.FakeXDomainRequest;\n        }\n        return sinon.FakeXDomainRequest;\n    };\n\n    sinon.FakeXDomainRequest = FakeXDomainRequest;\n})(this);\n\nif (typeof module == \"object\" && typeof require == \"function\") {\n    module.exports = sinon;\n}\n\nreturn sinon;}.call(typeof window != 'undefined' && window || {}));\n"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtRA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC97EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;","file":"test-support.js"}